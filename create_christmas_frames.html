<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ğŸ„ Christmas Frame Generator âœ¨</title>
    <style>
        body { 
            font-family: 'Georgia', 'Times New Roman', serif; 
            padding: 20px; 
            background: linear-gradient(135deg, #fefefe 0%, #fef7f7 50%, #fef2f2 100%);
            background-attachment: fixed;
            color: #1c1917;
            min-height: 100vh;
        }
        .container { 
            max-width: 900px; 
            margin: 0 auto; 
            background: rgba(255, 255, 255, 0.95); 
            padding: 30px; 
            border-radius: 20px; 
            box-shadow: 0 20px 25px -5px rgba(220, 38, 38, 0.1), 0 10px 10px -5px rgba(21, 185, 129, 0.05);
            border: 2px solid rgba(220, 38, 38, 0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .main-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #dc2626 0%, #15b981 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            font-size: 1.125rem;
            color: #57534e;
            margin-bottom: 20px;
        }
        .format-selector { 
            margin: 25px 0; 
            background: rgba(254, 247, 247, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(220, 38, 38, 0.1);
        }
        .format-selector h3 { 
            color: #dc2626; 
            font-size: 18px; 
            margin-bottom: 15px; 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .format-btn { 
            padding: 12px 20px; 
            margin: 8px; 
            border: 2px solid rgba(220, 38, 38, 0.2); 
            background: white; 
            color: #374151; 
            cursor: pointer; 
            border-radius: 12px; 
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .format-btn.active { 
            border-color: #dc2626; 
            background: linear-gradient(135deg, #dc2626 0%, #15b981 100%);
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }
        .format-btn:hover {
            border-color: #dc2626;
            background: rgba(220, 38, 38, 0.05);
            color: #dc2626;
            transform: translateY(-1px);
        }
        .format-btn.active:hover {
            background: linear-gradient(135deg, #b91c1c 0%, #059669 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
        }
        canvas { 
            border: 3px solid #dc2626; 
            display: block; 
            margin: 30px auto; 
            max-width: 450px; 
            height: auto; 
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(220, 38, 38, 0.2), 0 0 20px rgba(21, 185, 129, 0.1);
        }
        .action-buttons {
            text-align: center;
            margin: 30px 0;
        }
        button { 
            padding: 15px 30px; 
            font-size: 16px; 
            background: linear-gradient(135deg, #dc2626 0%, #15b981 100%); 
            color: white; 
            border: none; 
            border-radius: 12px; 
            cursor: pointer; 
            margin: 8px; 
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }
        button:hover { 
            background: linear-gradient(135deg, #b91c1c 0%, #059669 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
        }
        .info { 
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.05) 0%, rgba(21, 185, 129, 0.05) 100%); 
            padding: 20px; 
            border-radius: 15px; 
            margin: 25px 0; 
            border: 1px solid rgba(220, 38, 38, 0.1);
        }
        .canvas-info { 
            text-align: center; 
            margin: 15px 0; 
            font-size: 14px; 
            color: #57534e; 
            font-weight: 500;
        }
        .preview-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
            padding: 20px;
            background: rgba(254, 247, 247, 0.5);
            border-radius: 15px;
            border: 1px solid rgba(220, 38, 38, 0.1);
        }
        .preview-item {
            text-align: center;
            padding: 15px;
            border-radius: 12px;
            background: white;
            border: 1px solid rgba(220, 38, 38, 0.1);
            transition: all 0.3s ease;
        }
        .preview-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(220, 38, 38, 0.15);
        }
        .preview-emoji {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        .preview-name {
            font-size: 0.875rem;
            color: #dc2626;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="main-title">ğŸ„ Christmas Frame Generator âœ¨</h1>
            <p class="subtitle">Create festive holiday frames with Christmas magic</p>
        </div>
        
        <div class="format-selector">
            <h3>ğŸ é¸æ“‡è¼¸å‡ºæ ¼å¼ï¼š</h3>
            <button class="format-btn active" data-format="square">
                ğŸ“± æ­£æ–¹å½¢ (1080Ã—1080)
                <small>Instagram Posts</small>
            </button>
            <button class="format-btn" data-format="portrait">
                ğŸ“¸ ç›´å¼ (1080Ã—1350)
                <small>Instagram Portrait</small>
            </button>
            <button class="format-btn" data-format="story">
                ğŸ“± é™æ™‚å‹•æ…‹ (1080Ã—1920)
                <small>Stories & TikTok</small>
            </button>
        </div>
        
        <div class="format-selector">
            <h3>ğŸ¨ é¸æ“‡è–èª•é¢¨æ ¼ï¼š</h3>
            <button class="format-btn active" data-style="holly-border">
                ğŸŒ¿ å†¬é’é‚Šæ¡†
                <small>Classic Holly</small>
            </button>
            <button class="format-btn" data-style="snow-frame">
                â„ï¸ é›ªèŠ±é‚Šæ¡†
                <small>Winter Snow</small>
            </button>
            <button class="format-btn" data-style="gift-wrapper">
                ğŸ ç¦®ç‰©åŒ…è£
                <small>Gift Box Style</small>
            </button>
            <button class="format-btn" data-style="winter-glow">
                âœ¨ å†¬æ—¥å…‰æšˆ
                <small>Magical Glow</small>
            </button>
            <button class="format-btn" data-style="festive-lights">
                ğŸ„ ç¯€æ…¶ç‡ˆé£¾
                <small>Christmas Lights</small>
            </button>
        </div>
        
        <canvas id="frameCanvas"></canvas>
        <div class="canvas-info" id="canvasInfo">1080 Ã— 1080 åƒç´ </div>
        
        <div class="action-buttons">
            <button onclick="downloadFrame()">ğŸ ä¸‹è¼‰ç•¶å‰ç›¸æ¡†</button>
            <button onclick="downloadAllFrames()">ğŸ„ ä¸‹è¼‰æ‰€æœ‰æ ¼å¼</button>
        </div>
        
        <div class="preview-gallery">
            <div class="preview-item">
                <div class="preview-emoji">ğŸŒ¿</div>
                <div class="preview-name">å†¬é’é‚Šæ¡†</div>
            </div>
            <div class="preview-item">
                <div class="preview-emoji">â„ï¸</div>
                <div class="preview-name">é›ªèŠ±é‚Šæ¡†</div>
            </div>
            <div class="preview-item">
                <div class="preview-emoji">ğŸ</div>
                <div class="preview-name">ç¦®ç‰©åŒ…è£</div>
            </div>
            <div class="preview-item">
                <div class="preview-emoji">âœ¨</div>
                <div class="preview-name">å†¬æ—¥å…‰æšˆ</div>
            </div>
            <div class="preview-item">
                <div class="preview-emoji">ğŸ„</div>
                <div class="preview-name">ç¯€æ…¶ç‡ˆé£¾</div>
            </div>
        </div>
        
        <div class="info">
            <strong>ğŸ… è–èª•ç‰¹è‰²åŠŸèƒ½ï¼š</strong><br>
            â€¢ äº”ç¨®è–èª•ä¸»é¡Œé¢¨æ ¼ï¼Œæ¯ç¨®éƒ½æœ‰ç¨ç‰¹çš„ç¯€æ…¶å…ƒç´ <br>
            â€¢ è–èª•è‰²å½©æ­é…ï¼šç´…è‰²ã€ç¶ è‰²ã€é‡‘è‰²å®Œç¾èåˆ<br>
            â€¢ ç¯€æ…¶è£é£¾å…ƒç´ ï¼šé›ªèŠ±ã€å†¬é’ã€å½©ç‡ˆã€ç¦®ç‰©ç›’ç­‰<br>
            â€¢ æº«é¦¨çš„è–èª•ç¥ç¦æ–‡å­—ï¼š"Merry Christmas & Happy Holidays!"<br>
            â€¢ ä¸‹è¼‰æª”æ¡ˆå‘½åï¼šframe_[format]_[style]_[å°ºå¯¸].png<br>
            â€¢ å°‡æª”æ¡ˆæ”¾å…¥ assets/frames/ è³‡æ–™å¤¾ä»¥ä¾›è–èª•ä¸»é¡Œä½¿ç”¨
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('frameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasInfo = document.getElementById('canvasInfo');
        
        const formats = {
            square: { width: 1080, height: 1080, name: 'æ­£æ–¹å½¢', borderWidth: 50 },
            portrait: { width: 1080, height: 1350, name: 'ç›´å¼', borderWidth: 48 },
            story: { width: 1080, height: 1920, name: 'é™æ™‚å‹•æ…‹', borderWidth: 45 }
        };
        
        let currentFormat = 'square';
        let currentStyle = 'holly-border';
        
        function createFrame(format) {
            const config = formats[format];
            
            // Set canvas size
            canvas.width = config.width;
            canvas.height = config.height;
            canvasInfo.textContent = `${config.width} Ã— ${config.height} åƒç´ `;
            
            // Clear canvas
            ctx.clearRect(0, 0, config.width, config.height);
            
            // Draw frame based on selected style
            switch(currentStyle) {
                case 'holly-border':
                    drawHollyBorderFrame(ctx, config);
                    break;
                case 'snow-frame':
                    drawSnowFrameFrame(ctx, config);
                    break;
                case 'gift-wrapper':
                    drawGiftWrapperFrame(ctx, config);
                    break;
                case 'winter-glow':
                    drawWinterGlowFrame(ctx, config);
                    break;
                case 'festive-lights':
                    drawFestiveLightsFrame(ctx, config);
                    break;
                default:
                    drawHollyBorderFrame(ctx, config);
            }
            
            // åŠ å…¥è–èª•ç¥ç¦æ–‡å­—
            drawChristmasText(ctx, config.width, config.height, config.borderWidth, currentStyle);
        }
        
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        function drawChristmasText(ctx, canvasWidth, canvasHeight, borderWidth, style = 'holly-border') {
            ctx.save();
            
            // è¨ˆç®—æ–‡å­—ä½ç½® (åº•éƒ¨ä¸­å¤®)
            const textY = canvasHeight - borderWidth * 1.4;
            const textX = canvasWidth / 2;
            
            // è¨­å®šè–èª•æ–‡å­—æ¨£å¼
            const fontSize = Math.max(65, borderWidth * 2.2);
            ctx.font = `italic bold ${fontSize}px "Georgia", "Times New Roman", serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // æ ¹æ“šé¢¨æ ¼è¨­å®šæ–‡å­—é¡è‰²å’Œæ•ˆæœ
            let textColor, shadowColor, strokeColor, shadowBlur, shadowOffset;
            
            switch(style) {
                case 'holly-border':
                    textColor = '#dc2626'; // è–èª•ç´…
                    shadowColor = 'rgba(21, 185, 129, 0.6)';
                    strokeColor = 'rgba(255, 255, 255, 0.9)';
                    shadowBlur = 4;
                    shadowOffset = 2;
                    break;
                    
                case 'snow-frame':
                    textColor = '#1e40af'; // å†°é›ªè—
                    shadowColor = 'rgba(219, 234, 254, 0.8)';
                    strokeColor = 'rgba(255, 255, 255, 0.9)';
                    shadowBlur = 6;
                    shadowOffset = 2;
                    break;
                    
                case 'gift-wrapper':
                    textColor = '#d97706'; // é‡‘è‰²
                    shadowColor = 'rgba(220, 38, 38, 0.5)';
                    strokeColor = 'rgba(255, 255, 255, 0.8)';
                    shadowBlur = 3;
                    shadowOffset = 2;
                    break;
                    
                case 'winter-glow':
                    textColor = '#ffffff'; // ç´”ç™½
                    shadowColor = 'rgba(59, 130, 246, 0.8)';
                    strokeColor = 'rgba(21, 185, 129, 0.6)';
                    shadowBlur = 8;
                    shadowOffset = 0;
                    break;
                    
                case 'festive-lights':
                    textColor = '#fbbf24'; // æš–é‡‘è‰²
                    shadowColor = 'rgba(239, 68, 68, 0.6)';
                    strokeColor = 'rgba(21, 185, 129, 0.7)';
                    shadowBlur = 5;
                    shadowOffset = 1;
                    break;
                    
                default:
                    textColor = '#dc2626';
                    shadowColor = 'rgba(21, 185, 129, 0.5)';
                    strokeColor = 'rgba(255, 255, 255, 0.8)';
                    shadowBlur = 3;
                    shadowOffset = 2;
            }
            
            // è¨­å®šæ–‡å­—æ¨£å¼
            ctx.fillStyle = textColor;
            
            // åŠ å…¥æ–‡å­—é™°å½±æ•ˆæœ
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = shadowBlur;
            ctx.shadowOffsetX = shadowOffset;
            ctx.shadowOffsetY = shadowOffset;
            
            // ç¹ªè£½è–èª•ç¥ç¦æ–‡å­—
            ctx.fillText('Merry Christmas!', textX, textY);
            
            // åŠ å…¥æ–‡å­—å¤–æ¡†
            ctx.shadowColor = 'transparent';
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.strokeText('Merry Christmas!', textX, textY);
            
            ctx.restore();
        }
        
        // ğŸŒ¿ å†¬é’é‚Šæ¡†é¢¨æ ¼ - ç¶“å…¸è–èª•ï¼ˆå¢å¼·ç‰ˆï¼‰
        function drawHollyBorderFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = 12;
            
            // ä¸»é‚Šæ¡† - æ·±ç¶ è‰²æ¼¸è®Š
            ctx.save();
            const greenGradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            greenGradient.addColorStop(0, '#166534');
            greenGradient.addColorStop(0.5, '#059669');
            greenGradient.addColorStop(1, '#166534');
            
            ctx.strokeStyle = greenGradient;
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§é‚Šæ¡† - è–èª•ç´…æ¼¸è®Š
            const redGradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            redGradient.addColorStop(0, '#dc2626');
            redGradient.addColorStop(0.5, '#f87171');
            redGradient.addColorStop(1, '#dc2626');
            
            ctx.strokeStyle = redGradient;
            ctx.lineWidth = 4;
            const innerMargin = borderWidth - 8;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 2);
            ctx.stroke();
            
            // ç¹ªè£½æ­¡æ¨‚å†¬é’è‘‰è£é£¾
            drawEnhancedHollyDecorations(ctx, config, borderWidth);
            
            // æ·»åŠ è–èª•éˆ´éº
            drawChristmasBells(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawEnhancedHollyDecorations(ctx, config, borderWidth) {
            const positions = [
                {x: borderWidth * 1.5, y: borderWidth * 1.5}, // å·¦ä¸Š
                {x: config.width - borderWidth * 1.5, y: borderWidth * 1.5}, // å³ä¸Š
                {x: borderWidth * 1.5, y: config.height - borderWidth * 1.5}, // å·¦ä¸‹
                {x: config.width - borderWidth * 1.5, y: config.height - borderWidth * 1.5} // å³ä¸‹
            ];
            
            positions.forEach((pos, index) => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate((index * Math.PI) / 6); // ç¨å¾®æ—‹è½‰å¢åŠ å‹•æ„Ÿ
                
                // æ›´å¤§æ›´è±å¯Œçš„å†¬é’è‘‰ - æ¼¸å±¤ç¶ è‰²
                const leafGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                leafGradient.addColorStop(0, '#15b981');
                leafGradient.addColorStop(0.7, '#059669');
                leafGradient.addColorStop(1, '#064e3b');
                
                ctx.fillStyle = leafGradient;
                // ä¸»è¦å†¬é’è‘‰
                ctx.beginPath();
                ctx.ellipse(0, -10, 18, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(-10, 5, 12, 8, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(10, 5, 12, 8, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // é¡å¤–çš„å°è‘‰å­
                ctx.fillStyle = '#16a34a';
                ctx.beginPath();
                ctx.ellipse(-6, -6, 8, 5, Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(6, -6, 8, 5, -Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                
                // æ›´å¤šç´…è‰²æ¼¿æœ - å¸¶å…‰æ¾¤
                const berryGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 4);
                berryGradient.addColorStop(0, '#f87171');
                berryGradient.addColorStop(0.6, '#dc2626');
                berryGradient.addColorStop(1, '#7f1d1d');
                
                ctx.fillStyle = berryGradient;
                // æ¼¿æœç¾¤
                ctx.beginPath();
                ctx.arc(-5, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5, 2, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, 8, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-3, 5, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(3, -2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // æ·»åŠ å°æ˜Ÿæ˜Ÿè£é£¾
                ctx.fillStyle = '#fbbf24';
                drawStar(ctx, -12, -12, 3, 5);
                drawStar(ctx, 12, 12, 2, 4);
                
                ctx.restore();
            });
        }
        
        function drawChristmasBells(ctx, config, borderWidth) {
            const bellPositions = [
                {x: config.width / 2, y: borderWidth * 0.7},
                {x: config.width / 2, y: config.height - borderWidth * 0.7},
                {x: borderWidth * 0.7, y: config.height / 2},
                {x: config.width - borderWidth * 0.7, y: config.height / 2}
            ];
            
            bellPositions.forEach(pos => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                
                // éˆ´éºä¸»é«” - é‡‘è‰²æ¼¸è®Š
                const bellGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                bellGradient.addColorStop(0, '#fcd34d');
                bellGradient.addColorStop(0.7, '#f59e0b');
                bellGradient.addColorStop(1, '#d97706');
                
                ctx.fillStyle = bellGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // éˆ´éºé«˜å…‰
                ctx.fillStyle = '#fef3c7';
                ctx.beginPath();
                ctx.arc(-2, -2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // éˆ´éºé ‚éƒ¨
                ctx.fillStyle = '#92400e';
                ctx.fillRect(-2, -8, 4, 3);
                
                // å°éˆ´éºå…§èŠ¯
                ctx.fillStyle = '#78350f';
                ctx.beginPath();
                ctx.arc(0, 2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        function drawStar(ctx, x, y, innerRadius, outerRadius) {
            const spikes = 5;
            let rot = Math.PI / 2 * 3;
            const step = Math.PI / spikes;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();
            ctx.moveTo(0, -outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(Math.cos(rot) * outerRadius, Math.sin(rot) * outerRadius);
                rot += step;
                ctx.lineTo(Math.cos(rot) * innerRadius, Math.sin(rot) * innerRadius);
                rot += step;
            }
            
            ctx.lineTo(0, -outerRadius);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        // â„ï¸ é›ªèŠ±é‚Šæ¡†é¢¨æ ¼ - å†¬æ—¥ç´”ç™½
        function drawSnowFrameFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = borderWidth * 0.4;
            
            // ä¸»é‚Šæ¡† - å†°è—è‰²æ¼¸è®Š
            const gradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            gradient.addColorStop(0, '#dbeafe');    // æ·ºè—
            gradient.addColorStop(0.5, '#bfdbfe');  // ä¸­è—
            gradient.addColorStop(1, '#93c5fd');    // è—è‰²
            
            ctx.save();
            ctx.strokeStyle = gradient;
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§é‚Šæ¡† - ç™½è‰²
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            const innerMargin = borderWidth - 6;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 3);
            ctx.stroke();
            
            // ç¹ªè£½é›ªèŠ±è£é£¾
            drawSnowflakeDecorations(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawSnowflakeDecorations(ctx, config, borderWidth) {
            const snowflakes = [
                {x: borderWidth * 1.5, y: borderWidth * 1.5, size: 0.8},
                {x: config.width - borderWidth * 1.5, y: borderWidth * 1.5, size: 1.0},
                {x: borderWidth * 1.5, y: config.height - borderWidth * 1.5, size: 1.2},
                {x: config.width - borderWidth * 1.5, y: config.height - borderWidth * 1.5, size: 0.9},
                {x: config.width / 2, y: borderWidth, size: 1.1},
                {x: config.width / 2, y: config.height - borderWidth, size: 1.0}
            ];
            
            snowflakes.forEach(flake => {
                ctx.save();
                ctx.translate(flake.x, flake.y);
                ctx.scale(flake.size, flake.size);
                
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                // ç¹ªè£½å…­è§’é›ªèŠ±
                for (let i = 0; i < 6; i++) {
                    ctx.save();
                    ctx.rotate((i * Math.PI) / 3);
                    
                    // ä¸»ç·š
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(0, 12);
                    ctx.stroke();
                    
                    // åˆ†æ”¯
                    ctx.beginPath();
                    ctx.moveTo(-4, -8);
                    ctx.lineTo(0, -12);
                    ctx.lineTo(4, -8);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(-4, 8);
                    ctx.lineTo(0, 12);
                    ctx.lineTo(4, 8);
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                ctx.restore();
            });
        }
        
        // ğŸ ç¦®ç‰©åŒ…è£é¢¨æ ¼ - é©šå–œç¦®å“ï¼ˆæ­¡æ¨‚å¢å¼·ç‰ˆï¼‰
        function drawGiftWrapperFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            
            // ä¸»é‚Šæ¡† - æ¼¸è®Šç¦®ç‰©ç›’èƒŒæ™¯
            ctx.save();
            const bgGradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            bgGradient.addColorStop(0, '#dc2626');
            bgGradient.addColorStop(0.3, '#f87171');
            bgGradient.addColorStop(0.7, '#dc2626');
            bgGradient.addColorStop(1, '#b91c1c');
            
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, config.width, config.height);
            
            // æ·»åŠ æ­¡æ¨‚çš„åœ“é»åœ–æ¡ˆ
            drawFestivePatterns(ctx, config);
            
            // ç™½è‰²å…§æ¡†
            const innerMargin = borderWidth;
            ctx.fillStyle = '#ffffff';
            drawRoundedRect(ctx, innerMargin, innerMargin, 
                config.width - 2 * innerMargin, config.height - 2 * innerMargin, 8);
            ctx.fill();
            
            // ç¹ªè£½è±ªè¯ç·å¸¶è£é£¾
            drawLuxuryGiftRibbons(ctx, config, borderWidth);
            
            // ç¹ªè£½æ›´å¤šç¦®ç‰©è£é£¾
            drawEnhancedGiftDecorations(ctx, config, borderWidth);
            
            // æ·»åŠ è–èª•è¥ªå’Œç³–æœ
            drawChristmasStockings(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawFestivePatterns(ctx, config) {
            // æ·»åŠ æ­¡æ¨‚çš„åœ“é»å’Œæ˜Ÿæ˜Ÿåœ–æ¡ˆ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            
            for (let x = 20; x < config.width; x += 60) {
                for (let y = 20; y < config.height; y += 60) {
                    if (Math.random() > 0.7) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // æ·»åŠ å°æ˜Ÿæ˜Ÿ
            ctx.fillStyle = 'rgba(251, 191, 36, 0.3)';
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * config.width;
                const y = Math.random() * config.height;
                drawStar(ctx, x, y, 2, 4);
            }
        }
        
        function drawLuxuryGiftRibbons(ctx, config, borderWidth) {
            const ribbonWidth = borderWidth * 0.7;
            
            // å‚ç›´ç·å¸¶ - è±ªè¯é‡‘è‰²æ¼¸è®Š
            const gradient1 = ctx.createLinearGradient(config.width/2 - ribbonWidth/2, 0, config.width/2 + ribbonWidth/2, 0);
            gradient1.addColorStop(0, '#f59e0b');
            gradient1.addColorStop(0.2, '#fcd34d');
            gradient1.addColorStop(0.5, '#fbbf24');
            gradient1.addColorStop(0.8, '#fcd34d');
            gradient1.addColorStop(1, '#f59e0b');
            
            ctx.fillStyle = gradient1;
            ctx.fillRect(config.width/2 - ribbonWidth/2, 0, ribbonWidth, config.height);
            
            // ç·å¸¶é‚Šç·£è£é£¾
            ctx.fillStyle = '#d97706';
            ctx.fillRect(config.width/2 - ribbonWidth/2, 0, 3, config.height);
            ctx.fillRect(config.width/2 + ribbonWidth/2 - 3, 0, 3, config.height);
            
            // æ°´å¹³ç·å¸¶ - è±ªè¯é‡‘è‰²æ¼¸è®Š
            const gradient2 = ctx.createLinearGradient(0, config.height/2 - ribbonWidth/2, 0, config.height/2 + ribbonWidth/2);
            gradient2.addColorStop(0, '#f59e0b');
            gradient2.addColorStop(0.2, '#fcd34d');
            gradient2.addColorStop(0.5, '#fbbf24');
            gradient2.addColorStop(0.8, '#fcd34d');
            gradient2.addColorStop(1, '#f59e0b');
            
            ctx.fillStyle = gradient2;
            ctx.fillRect(0, config.height/2 - ribbonWidth/2, config.width, ribbonWidth);
            
            // æ°´å¹³ç·å¸¶é‚Šç·£è£é£¾
            ctx.fillStyle = '#d97706';
            ctx.fillRect(0, config.height/2 - ribbonWidth/2, config.width, 3);
            ctx.fillRect(0, config.height/2 + ribbonWidth/2 - 3, config.width, 3);
            
            // è±ªè¯è´è¶çµ
            drawLuxuryBowDecoration(ctx, config.width/2, config.height/2, borderWidth * 1.0);
        }
        
        function drawLuxuryBowDecoration(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            
            // è´è¶çµé™°å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.translate(3, 3);
            ctx.beginPath();
            ctx.ellipse(-size/2.5, 0, size/1.8, size/2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(size/2.5, 0, size/1.8, size/2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.translate(-3, -3);
            
            // è´è¶çµä¸»é«” - è±ªè¯é‡‘è‰²
            const bowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            bowGradient.addColorStop(0, '#fcd34d');
            bowGradient.addColorStop(0.6, '#f59e0b');
            bowGradient.addColorStop(1, '#d97706');
            
            ctx.fillStyle = bowGradient;
            
            // å·¦ç¿¼
            ctx.beginPath();
            ctx.ellipse(-size/2.5, 0, size/1.8, size/2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å³ç¿¼
            ctx.beginPath();
            ctx.ellipse(size/2.5, 0, size/1.8, size/2.5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸­å¿ƒçµ - æ›´æ·±çš„é‡‘è‰²
            ctx.fillStyle = '#b45309';
            ctx.fillRect(-size/6, -size/2.2, size/3, size/1.1);
            
            // ä¸­å¿ƒçµé«˜å…‰
            ctx.fillStyle = '#fcd34d';
            ctx.fillRect(-size/8, -size/3, size/4, size/6);
            
            // è´è¶çµæ¢ç´‹è£é£¾
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-size/1.5, -size/4);
            ctx.lineTo(-size/3, size/4);
            ctx.moveTo(size/3, -size/4);
            ctx.lineTo(size/1.5, size/4);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawBowDecoration(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            
            // è´è¶çµ - æ·±é‡‘è‰²
            ctx.fillStyle = '#d97706';
            
            // å·¦ç¿¼
            ctx.beginPath();
            ctx.ellipse(-size/3, 0, size/2, size/3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å³ç¿¼
            ctx.beginPath();
            ctx.ellipse(size/3, 0, size/2, size/3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸­å¿ƒçµ
            ctx.fillStyle = '#b45309';
            ctx.fillRect(-size/8, -size/4, size/4, size/2);
            
            ctx.restore();
        }
        
        function drawEnhancedGiftDecorations(ctx, config, borderWidth) {
            // æ›´å¤šè§’è½çš„ç¦®ç‰©ç›’å’Œè£é£¾
            const giftSize = borderWidth * 0.5;
            const positions = [
                {x: borderWidth * 0.8, y: borderWidth * 0.8, color: '#15b981'},
                {x: config.width - borderWidth * 0.8, y: borderWidth * 0.8, color: '#dc2626'},
                {x: borderWidth * 0.8, y: config.height - borderWidth * 0.8, color: '#3b82f6'},
                {x: config.width - borderWidth * 0.8, y: config.height - borderWidth * 0.8, color: '#8b5cf6'}
            ];
            
            positions.forEach((pos, index) => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate((index * Math.PI) / 8); // è¼•å¾®æ—‹è½‰
                
                // ç¦®ç‰©ç›’é™°å½±
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(-giftSize/2 + 2, -giftSize/2 + 2, giftSize, giftSize);
                
                // ä¸»ç¦®ç‰©ç›’ - æ¼¸è®Šè‰²
                const giftGradient = ctx.createLinearGradient(-giftSize/2, -giftSize/2, giftSize/2, giftSize/2);
                giftGradient.addColorStop(0, pos.color);
                giftGradient.addColorStop(1, pos.color + 'CC');
                
                ctx.fillStyle = giftGradient;
                ctx.fillRect(-giftSize/2, -giftSize/2, giftSize, giftSize);
                
                // è±ªè¯ç·å¸¶
                const ribbonGradient = ctx.createLinearGradient(-giftSize/2, -giftSize/2, giftSize/2, giftSize/2);
                ribbonGradient.addColorStop(0, '#fcd34d');
                ribbonGradient.addColorStop(1, '#f59e0b');
                
                ctx.fillStyle = ribbonGradient;
                ctx.fillRect(-giftSize/2, -giftSize/10, giftSize, giftSize/5);
                ctx.fillRect(-giftSize/10, -giftSize/2, giftSize/5, giftSize);
                
                // å°è´è¶çµ
                ctx.fillStyle = '#d97706';
                ctx.beginPath();
                ctx.arc(-giftSize/6, 0, giftSize/8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(giftSize/6, 0, giftSize/8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(-giftSize/12, -giftSize/8, giftSize/6, giftSize/4);
                
                ctx.restore();
            });
        }
        
        function drawChristmasStockings(ctx, config, borderWidth) {
            const stockingPositions = [
                {x: borderWidth * 1.8, y: config.height / 2},
                {x: config.width - borderWidth * 1.8, y: config.height / 2}
            ];
            
            stockingPositions.forEach((pos, index) => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                if (index === 1) ctx.scale(-1, 1); // é¡åƒç¬¬äºŒå€‹
                
                // è–èª•è¥ªä¸»é«”
                const sockGradient = ctx.createLinearGradient(0, -15, 0, 20);
                sockGradient.addColorStop(0, '#dc2626');
                sockGradient.addColorStop(1, '#7f1d1d');
                
                ctx.fillStyle = sockGradient;
                ctx.beginPath();
                ctx.roundRect(-8, -15, 16, 25, 3);
                ctx.fill();
                
                // è¥ªå­è…³éƒ¨
                ctx.beginPath();
                ctx.roundRect(0, 8, 12, 8, 3);
                ctx.fill();
                
                // ç™½è‰²è¥ªå£
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-8, -15, 16, 5);
                
                // é›ªèŠ±è£é£¾
                ctx.fillStyle = '#bfdbfe';
                drawStar(ctx, 0, -5, 2, 3);
                drawStar(ctx, 6, 2, 1, 2);
                
                ctx.restore();
            });
        }
        
        // âœ¨ å†¬æ—¥å…‰æšˆé¢¨æ ¼ - æº«æš–å…‰èŠ’
        function drawWinterGlowFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = borderWidth * 0.5;
            
            // å‰µå»ºå…‰æšˆæ¼¸è®Š
            const glowGradient = ctx.createRadialGradient(
                config.width/2, config.height/2, 0,
                config.width/2, config.height/2, Math.max(config.width, config.height)/2
            );
            glowGradient.addColorStop(0, 'rgba(59, 130, 246, 0.1)');
            glowGradient.addColorStop(0.7, 'rgba(147, 197, 253, 0.3)');
            glowGradient.addColorStop(1, 'rgba(59, 130, 246, 0.6)');
            
            ctx.save();
            
            // å…‰æšˆèƒŒæ™¯
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, config.width, config.height);
            
            // ä¸»é‚Šæ¡†
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 20;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§ç™¼å…‰
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#bfdbfe';
            ctx.strokeStyle = 'rgba(191, 219, 254, 0.6)';
            ctx.lineWidth = 6;
            const innerMargin = borderWidth - 8;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 4);
            ctx.stroke();
            
            // ç¹ªè£½å…‰é»è£é£¾
            drawGlowDecorations(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawGlowDecorations(ctx, config, borderWidth) {
            const lightPositions = [
                {x: borderWidth * 1.2, y: borderWidth * 1.2, size: 8, color: '#3b82f6'},
                {x: config.width - borderWidth * 1.2, y: borderWidth * 1.2, size: 12, color: '#8b5cf6'},
                {x: borderWidth * 1.2, y: config.height - borderWidth * 1.2, size: 10, color: '#06b6d4'},
                {x: config.width - borderWidth * 1.2, y: config.height - borderWidth * 1.2, size: 9, color: '#10b981'},
                {x: config.width/2, y: borderWidth * 0.8, size: 15, color: '#f59e0b'},
                {x: config.width/2, y: config.height - borderWidth * 0.8, size: 11, color: '#ef4444'}
            ];
            
            // æ·»åŠ æ›´å¤šéš¨æ©Ÿå…‰é»
            for (let i = 0; i < 25; i++) {
                const colors = ['#3b82f6', '#8b5cf6', '#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#ec4899'];
                lightPositions.push({
                    x: borderWidth * 2 + Math.random() * (config.width - 4 * borderWidth),
                    y: borderWidth * 2 + Math.random() * (config.height - 4 * borderWidth),
                    size: 3 + Math.random() * 6,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            
            lightPositions.forEach((light, index) => {
                ctx.save();
                
                // å‹•æ…‹äº®åº¦è®ŠåŒ–
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.003 + index * 0.5);
                
                // å¤–å±¤å…‰æšˆ
                const outerGlow = ctx.createRadialGradient(
                    light.x, light.y, 0,
                    light.x, light.y, light.size * 4
                );
                outerGlow.addColorStop(0, light.color + Math.floor(pulse * 100).toString(16).padStart(2, '0'));
                outerGlow.addColorStop(0.3, light.color + Math.floor(pulse * 60).toString(16).padStart(2, '0'));
                outerGlow.addColorStop(0.7, light.color + Math.floor(pulse * 30).toString(16).padStart(2, '0'));
                outerGlow.addColorStop(1, light.color + '00');
                
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(light.x, light.y, light.size * 4, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸»ç™¼å…‰é«”
                const mainGlow = ctx.createRadialGradient(
                    light.x, light.y, 0,
                    light.x, light.y, light.size * 2
                );
                mainGlow.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
                mainGlow.addColorStop(0.4, light.color + Math.floor(pulse * 180).toString(16).padStart(2, '0'));
                mainGlow.addColorStop(1, light.color + Math.floor(pulse * 80).toString(16).padStart(2, '0'));
                
                ctx.fillStyle = mainGlow;
                ctx.beginPath();
                ctx.arc(light.x, light.y, light.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸­å¿ƒæ ¸å¿ƒ
                const coreGlow = ctx.createRadialGradient(
                    light.x - light.size/3, light.y - light.size/3, 0,
                    light.x, light.y, light.size
                );
                coreGlow.addColorStop(0, `rgba(255, 255, 255, ${pulse})`);
                coreGlow.addColorStop(0.6, light.color);
                coreGlow.addColorStop(1, light.color + 'AA');
                
                ctx.fillStyle = coreGlow;
                ctx.beginPath();
                ctx.arc(light.x, light.y, light.size, 0, Math.PI * 2);
                ctx.fill();
                
                // é«˜å…‰é»
                ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
                ctx.beginPath();
                ctx.arc(light.x - light.size/3, light.y - light.size/3, light.size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // å…‰ç·šæ•ˆæœ
                if (light.size > 8) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 * pulse})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let ray = 0; ray < 8; ray++) {
                        const angle = (ray * Math.PI * 2) / 8;
                        const startX = light.x + Math.cos(angle) * light.size;
                        const startY = light.y + Math.sin(angle) * light.size;
                        const endX = light.x + Math.cos(angle) * light.size * 3;
                        const endY = light.y + Math.sin(angle) * light.size * 3;
                        
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                    }
                    ctx.stroke();
                }
                
                ctx.restore();
            });
            
            // æ·»åŠ é­”æ³•ç²’å­æ•ˆæœ
            drawMagicParticles(ctx, config);
        }
        
        function drawMagicParticles(ctx, config) {
            const particleColors = ['#fbbf24', '#f472b6', '#a78bfa', '#34d399', '#60a5fa'];
            
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * config.width;
                const y = Math.random() * config.height;
                const time = Date.now() * 0.002 + i;
                const size = 1 + Math.sin(time) * 0.5;
                const alpha = 0.3 + 0.3 * Math.sin(time * 2);
                
                ctx.fillStyle = particleColors[i % particleColors.length] + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ğŸ„ ç¯€æ…¶ç‡ˆé£¾é¢¨æ ¼ - ç¹½ç´›äº®éº—
        function drawFestiveLightsFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = 10;
            
            // ä¸»é‚Šæ¡† - æ·±ç¶ è‰²è–èª•æ¨¹è‰²
            ctx.save();
            ctx.strokeStyle = '#166534';
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§é‚Šæ¡† - æš–é‡‘è‰²
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 4;
            const innerMargin = borderWidth - 8;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 2);
            ctx.stroke();
            
            // ç¹ªè£½å½©ç‡ˆè£é£¾
            drawChristmasLights(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawChristmasLights(ctx, config, borderWidth) {
            const lightColors = ['#dc2626', '#15b981', '#3b82f6', '#f59e0b', '#8b5cf6', '#ec4899', '#16a34a', '#f97316'];
            const lightSize = 10;
            const spacing = 35;
            
            // ç¹ªè£½ç‡ˆä¸²ç·šæ¢
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 2;
            
            // ä¸Šé‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(borderWidth, borderWidth/2);
            ctx.lineTo(config.width - borderWidth, borderWidth/2);
            ctx.stroke();
            
            // ä¸‹é‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(borderWidth, config.height - borderWidth/2);
            ctx.lineTo(config.width - borderWidth, config.height - borderWidth/2);
            ctx.stroke();
            
            // å·¦é‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(borderWidth/2, borderWidth);
            ctx.lineTo(borderWidth/2, config.height - borderWidth);
            ctx.stroke();
            
            // å³é‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(config.width - borderWidth/2, borderWidth);
            ctx.lineTo(config.width - borderWidth/2, config.height - borderWidth);
            ctx.stroke();
            
            // ä¸Šé‚Šç‡ˆä¸² - é–ƒçˆæ•ˆæœ
            for (let x = borderWidth + spacing; x < config.width - borderWidth; x += spacing) {
                const colorIndex = Math.floor((x / spacing) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + x * 0.01);
                drawEnhancedChristmasLight(ctx, x, borderWidth/2, lightSize, lightColors[colorIndex], brightness);
            }
            
            // ä¸‹é‚Šç‡ˆä¸²
            for (let x = borderWidth + spacing; x < config.width - borderWidth; x += spacing) {
                const colorIndex = Math.floor((x / spacing + 3) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + x * 0.01 + Math.PI);
                drawEnhancedChristmasLight(ctx, x, config.height - borderWidth/2, lightSize, lightColors[colorIndex], brightness);
            }
            
            // å·¦é‚Šç‡ˆä¸²
            for (let y = borderWidth + spacing; y < config.height - borderWidth; y += spacing) {
                const colorIndex = Math.floor((y / spacing + 1) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + y * 0.01 + Math.PI/2);
                drawEnhancedChristmasLight(ctx, borderWidth/2, y, lightSize, lightColors[colorIndex], brightness);
            }
            
            // å³é‚Šç‡ˆä¸²
            for (let y = borderWidth + spacing; y < config.height - borderWidth; y += spacing) {
                const colorIndex = Math.floor((y / spacing + 4) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + y * 0.01 + Math.PI * 1.5);
                drawEnhancedChristmasLight(ctx, config.width - borderWidth/2, y, lightSize, lightColors[colorIndex], brightness);
            }
            
            // æ·»åŠ é–ƒäº®çš„æ˜Ÿæ˜Ÿè£é£¾
            drawTwinklingStars(ctx, config, borderWidth);
        }
        
        function drawTwinklingStars(ctx, config, borderWidth) {
            const starPositions = [
                {x: config.width * 0.2, y: config.height * 0.2},
                {x: config.width * 0.8, y: config.height * 0.2},
                {x: config.width * 0.2, y: config.height * 0.8},
                {x: config.width * 0.8, y: config.height * 0.8},
                {x: config.width * 0.5, y: config.height * 0.15},
                {x: config.width * 0.5, y: config.height * 0.85}
            ];
            
            starPositions.forEach((star, index) => {
                const twinkle = 0.5 + 0.5 * Math.sin(Date.now() * 0.005 + index);
                ctx.fillStyle = `rgba(251, 191, 36, ${twinkle})`;
                drawStar(ctx, star.x, star.y, 3, 6);
                
                // æ˜Ÿæ˜Ÿå…‰æšˆ
                const starGlow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, 15);
                starGlow.addColorStop(0, `rgba(251, 191, 36, ${twinkle * 0.3})`);
                starGlow.addColorStop(1, 'rgba(251, 191, 36, 0)');
                
                ctx.fillStyle = starGlow;
                ctx.beginPath();
                ctx.arc(star.x, star.y, 15, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawEnhancedChristmasLight(ctx, x, y, size, color, brightness = 1) {
            ctx.save();
            
            // å¼·åŒ–çš„ç‡ˆæ³¡ç™¼å…‰æ•ˆæœ
            const lightGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
            lightGradient.addColorStop(0, color);
            lightGradient.addColorStop(0.3, color + Math.floor(brightness * 200).toString(16).padStart(2, '0'));
            lightGradient.addColorStop(0.7, color + Math.floor(brightness * 100).toString(16).padStart(2, '0'));
            lightGradient.addColorStop(1, color + '10');
            
            ctx.fillStyle = lightGradient;
            ctx.beginPath();
            ctx.arc(x, y, size * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // ç‡ˆæ³¡å¤–æ®¼ - ç«‹é«”æ•ˆæœ
            const bulbGradient = ctx.createRadialGradient(x - size/3, y - size/3, 0, x, y, size);
            bulbGradient.addColorStop(0, '#ffffff');
            bulbGradient.addColorStop(0.3, color);
            bulbGradient.addColorStop(1, color + 'CC');
            
            ctx.fillStyle = bulbGradient;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // ç‡ˆæ³¡é ‚éƒ¨é‡‘å±¬éƒ¨åˆ†
            ctx.fillStyle = '#4b5563';
            ctx.fillRect(x - size/3, y - size - 3, size * 2/3, 6);
            
            // ç‡ˆæ³¡é«˜å…‰
            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * brightness})`;
            ctx.beginPath();
            ctx.arc(x - size/2, y - size/2, size/2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // å°é«˜å…‰é»
            ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * brightness})`;
            ctx.beginPath();
            ctx.arc(x - size/4, y - size/4, size/6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function switchFormat(format) {
            currentFormat = format;
            
            // Update button states
            document.querySelectorAll('.format-btn[data-format]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.format === format);
            });
            
            createFrame(format);
        }
        
        function switchStyle(style) {
            currentStyle = style;
            
            // Update button states
            document.querySelectorAll('.format-btn[data-style]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.style === style);
            });
            
            createFrame(currentFormat);
        }
        
        function downloadFrame() {
            const config = formats[currentFormat];
            const filename = `frame_${currentFormat}_${currentStyle}_${config.width}x${config.height}.png`;
            
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }
        
        async function downloadAllFrames() {
            const originalFormat = currentFormat;
            const originalStyle = currentStyle;
            
            const styles = ['holly-border', 'snow-frame', 'gift-wrapper', 'winter-glow', 'festive-lights'];
            
            for (const [format, config] of Object.entries(formats)) {
                for (const style of styles) {
                    // Switch to specific format and style
                    currentFormat = format;
                    currentStyle = style;
                    createFrame(format);
                    
                    // Wait a bit for rendering
                    await new Promise(resolve => setTimeout(resolve, 150));
                    
                    const filename = `frame_${format}_${style}_${config.width}x${config.height}.png`;
                    
                    canvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }, 'image/png', 1.0);
                    
                    await new Promise(resolve => setTimeout(resolve, 400));
                }
            }
            
            // Restore original format and style
            switchFormat(originalFormat);
            switchStyle(originalStyle);
        }
        
        // Setup event listeners
        document.querySelectorAll('.format-btn[data-format]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                switchFormat(e.currentTarget.dataset.format);
            });
        });
        
        // Style selector event listeners
        document.querySelectorAll('.format-btn[data-style]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                switchStyle(e.currentTarget.dataset.style);
            });
        });
        
        // åŠ å…¥è–èª•éŸ³æ¨‚ä¸»é¡Œè¦–è¦ºå…ƒç´ 
        function addMusicalElements(ctx, config, borderWidth) {
            const notePositions = [
                {x: config.width * 0.15, y: config.height * 0.25, type: 'quarter'},
                {x: config.width * 0.85, y: config.height * 0.3, type: 'eighth'},
                {x: config.width * 0.2, y: config.height * 0.75, type: 'half'},
                {x: config.width * 0.8, y: config.height * 0.7, type: 'quarter'},
                {x: config.width * 0.5, y: config.height * 0.12, type: 'treble'}
            ];
            
            notePositions.forEach((note, index) => {
                ctx.save();
                ctx.translate(note.x, note.y);
                
                const bounce = Math.sin(Date.now() * 0.003 + index) * 3;
                ctx.translate(0, bounce);
                
                // éŸ³ç¬¦é¡è‰²
                const noteColors = ['#fbbf24', '#f87171', '#34d399', '#60a5fa', '#a78bfa'];
                ctx.fillStyle = noteColors[index % noteColors.length];
                
                switch(note.type) {
                    case 'quarter':
                        // å››åˆ†éŸ³ç¬¦
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        ctx.fill();
                        // ç¬¦æ¡¿
                        ctx.fillRect(5, -20, 2, 20);
                        break;
                        
                    case 'eighth':
                        // å…«åˆ†éŸ³ç¬¦
                        ctx.beginPath();
                        ctx.arc(0, 0, 5, 0, Math.PI * 2);
                        ctx.fill();
                        // ç¬¦æ¡¿
                        ctx.fillRect(4, -18, 2, 18);
                        // ç¬¦å°¾
                        ctx.beginPath();
                        ctx.moveTo(6, -18);
                        ctx.quadraticCurveTo(12, -15, 8, -10);
                        ctx.lineTo(6, -12);
                        ctx.fill();
                        break;
                        
                    case 'half':
                        // äºŒåˆ†éŸ³ç¬¦
                        ctx.strokeStyle = noteColors[index % noteColors.length];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        ctx.stroke();
                        // ç¬¦æ¡¿
                        ctx.fillRect(5, -22, 2, 22);
                        break;
                        
                    case 'treble':
                        // é«˜éŸ³è­œè™Ÿ
                        ctx.beginPath();
                        ctx.moveTo(-3, -10);
                        ctx.quadraticCurveTo(-8, -15, -3, -20);
                        ctx.quadraticCurveTo(5, -18, 3, -8);
                        ctx.quadraticCurveTo(8, -5, 3, 0);
                        ctx.quadraticCurveTo(-2, 2, -4, -2);
                        ctx.quadraticCurveTo(-6, -8, -3, -10);
                        ctx.fill();
                        break;
                }
                
                // éŸ³ç¬¦å…‰æšˆ
                const noteGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                noteGlow.addColorStop(0, noteColors[index % noteColors.length] + '40');
                noteGlow.addColorStop(1, noteColors[index % noteColors.length] + '00');
                
                ctx.fillStyle = noteGlow;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
            
            // éŸ³æ¨‚ç·šæ¢æµå‹•æ•ˆæœ
            drawMusicalStaff(ctx, config);
        }
        
        function drawMusicalStaff(ctx, config) {
            const staffY = config.height * 0.1;
            const staffSpacing = 8;
            
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.3)';
            ctx.lineWidth = 1;
            
            // ç¹ªè£½äº”ç·šè­œï¼ˆéƒ¨åˆ†ï¼‰
            for (let i = 0; i < 3; i++) {
                const y = staffY + i * staffSpacing;
                const wave = Math.sin(Date.now() * 0.002 + i) * 5;
                
                ctx.beginPath();
                ctx.moveTo(config.width * 0.1, y + wave);
                
                for (let x = config.width * 0.1; x < config.width * 0.9; x += 10) {
                    const waveY = y + Math.sin((x * 0.02) + Date.now() * 0.002 + i) * 3;
                    ctx.lineTo(x, waveY);
                }
                
                ctx.stroke();
            }
        }
        
        // ä¿®æ”¹ç¾æœ‰çš„é‚Šæ¡†ç¹ªè£½å‡½æ•¸ï¼Œæ·»åŠ éŸ³æ¨‚å…ƒç´ 
        const originalCreateFrame = createFrame;
        createFrame = function(format) {
            originalCreateFrame(format);
            
            // ç‚ºæ‰€æœ‰é¢¨æ ¼æ·»åŠ éŸ³æ¨‚å…ƒç´ 
            const config = formats[format];
            if (currentStyle === 'festive-lights' || currentStyle === 'winter-glow') {
                addMusicalElements(ctx, config, config.borderWidth);
            }
        };
        
        // å¢å¼·å‹•ç•«å¾ªç’°
        function startChristmasAnimation() {
            function animate() {
                if (currentStyle === 'festive-lights' || currentStyle === 'winter-glow' || 
                    currentStyle === 'snow-frame' || currentStyle === 'gift-wrapper') {
                    createFrame(currentFormat);
                }
                requestAnimationFrame(animate);
            }
            animate();
        }
        
        // Initialize
        createFrame(currentFormat);
        startChristmasAnimation();
        
        // Update todo status
        console.log('ğŸ„ Enhanced Christmas Frame Generator initialized successfully with music and animations!');
    </script>
</body>
</html>