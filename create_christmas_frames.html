<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ğŸ„ Christmas Frame Generator âœ¨</title>
    <style>
        body { 
            font-family: 'Georgia', 'Times New Roman', serif; 
            padding: 20px; 
            background: linear-gradient(135deg, #fefefe 0%, #fef7f7 50%, #fef2f2 100%);
            background-attachment: fixed;
            color: #1c1917;
            min-height: 100vh;
        }
        .container { 
            max-width: 900px; 
            margin: 0 auto; 
            background: rgba(255, 255, 255, 0.95); 
            padding: 30px; 
            border-radius: 20px; 
            box-shadow: 0 20px 25px -5px rgba(220, 38, 38, 0.1), 0 10px 10px -5px rgba(21, 185, 129, 0.05);
            border: 2px solid rgba(220, 38, 38, 0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .main-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #dc2626 0%, #15b981 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            font-size: 1.125rem;
            color: #57534e;
            margin-bottom: 20px;
        }
        .format-selector { 
            margin: 25px 0; 
            background: rgba(254, 247, 247, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(220, 38, 38, 0.1);
        }
        .format-selector h3 { 
            color: #dc2626; 
            font-size: 18px; 
            margin-bottom: 15px; 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .format-btn { 
            padding: 12px 20px; 
            margin: 8px; 
            border: 2px solid rgba(220, 38, 38, 0.2); 
            background: white; 
            color: #374151; 
            cursor: pointer; 
            border-radius: 12px; 
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .format-btn.active { 
            border-color: #dc2626; 
            background: linear-gradient(135deg, #dc2626 0%, #15b981 100%);
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }
        .format-btn:hover {
            border-color: #dc2626;
            background: rgba(220, 38, 38, 0.05);
            color: #dc2626;
            transform: translateY(-1px);
        }
        .format-btn.active:hover {
            background: linear-gradient(135deg, #b91c1c 0%, #059669 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
        }
        canvas { 
            border: 3px solid #dc2626; 
            display: block; 
            margin: 30px auto; 
            max-width: 450px; 
            height: auto; 
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(220, 38, 38, 0.2), 0 0 20px rgba(21, 185, 129, 0.1);
        }
        .action-buttons {
            text-align: center;
            margin: 30px 0;
        }
        button { 
            padding: 15px 30px; 
            font-size: 16px; 
            background: linear-gradient(135deg, #dc2626 0%, #15b981 100%); 
            color: white; 
            border: none; 
            border-radius: 12px; 
            cursor: pointer; 
            margin: 8px; 
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }
        button:hover { 
            background: linear-gradient(135deg, #b91c1c 0%, #059669 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
        }
        .info { 
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.05) 0%, rgba(21, 185, 129, 0.05) 100%); 
            padding: 20px; 
            border-radius: 15px; 
            margin: 25px 0; 
            border: 1px solid rgba(220, 38, 38, 0.1);
        }
        .canvas-info { 
            text-align: center; 
            margin: 15px 0; 
            font-size: 14px; 
            color: #57534e; 
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="main-title">ğŸ„ Christmas Frame Generator âœ¨</h1>
            <p class="subtitle">Create festive holiday frames with Christmas magic</p>
        </div>
        
        <div class="format-selector">
            <h3>ğŸ é¸æ“‡è¼¸å‡ºæ ¼å¼ï¼š</h3>
            <button class="format-btn active" data-format="square">
                ğŸ“± æ­£æ–¹å½¢ (1080Ã—1080)
                <small>Instagram Posts</small>
            </button>
            <button class="format-btn" data-format="portrait">
                ğŸ“¸ ç›´å¼ (1080Ã—1350)
                <small>Instagram Portrait</small>
            </button>
            <button class="format-btn" data-format="story">
                ğŸ“± é™æ™‚å‹•æ…‹ (1080Ã—1920)
                <small>Stories & TikTok</small>
            </button>
        </div>
        
        <div class="format-selector">
            <h3>ğŸ¨ é¸æ“‡è–èª•é¢¨æ ¼ï¼š</h3>
            <button class="format-btn active" data-style="hfp_polaroid">
                ğŸ“¸ ä¿¡å‹æ‹ç«‹å¾—
                <small>Vintage Polaroid</small>
            </button>
            <button class="format-btn" data-style="snow-frame">
                â„ï¸ é›ªèŠ±é‚Šæ¡†
                <small>Winter Snow</small>
            </button>
            <button class="format-btn" data-style="christmas-ornaments">
                ğŸ„ è–èª•é£¾å“
                <small>Christmas Ornaments</small>
            </button>
            <button class="format-btn" data-style="winter-glow">
                âœ¨ å†¬æ—¥å…‰æšˆ
                <small>Magical Glow</small>
            </button>
            <button class="format-btn" data-style="festive-lights">
                ğŸ„ ç¯€æ…¶ç‡ˆé£¾
                <small>Christmas Lights</small>
            </button>
        </div>
        
        <canvas id="frameCanvas"></canvas>
        <div class="canvas-info" id="canvasInfo">1080 Ã— 1080 åƒç´ </div>
        
        <div class="action-buttons">
            <button onclick="downloadFrame()">ğŸ ä¸‹è¼‰ç•¶å‰ç›¸æ¡†</button>
            <button onclick="downloadAllFrames()">ğŸ„ ä¸‹è¼‰æ‰€æœ‰æ ¼å¼</button>
        </div>
        
        
        <div class="info">
            <strong>ğŸ… è–èª•ç‰¹è‰²åŠŸèƒ½ï¼š</strong><br>
            â€¢ äº”ç¨®è–èª•ä¸»é¡Œé¢¨æ ¼ï¼Œæ¯ç¨®éƒ½æœ‰ç¨ç‰¹çš„ç¯€æ…¶å…ƒç´ <br>
            â€¢ è–èª•è‰²å½©æ­é…ï¼šç´…è‰²ã€ç¶ è‰²ã€é‡‘è‰²å®Œç¾èåˆ<br>
            â€¢ ç¯€æ…¶è£é£¾å…ƒç´ ï¼šé›ªèŠ±ã€å†¬é’ã€å½©ç‡ˆã€ç¦®ç‰©ç›’ç­‰<br>
            â€¢ æº«é¦¨çš„è–èª•ç¥ç¦æ–‡å­—ï¼š"Merry Christmas & Happy Holidays!"<br>
            â€¢ ä¸‹è¼‰æª”æ¡ˆå‘½åï¼šframe_[format]_[style]_[å°ºå¯¸].png<br>
            â€¢ å°‡æª”æ¡ˆæ”¾å…¥ assets/frames/ è³‡æ–™å¤¾ä»¥ä¾›è–èª•ä¸»é¡Œä½¿ç”¨
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('frameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasInfo = document.getElementById('canvasInfo');
        
        const formats = {
            square: { width: 1080, height: 1080, name: 'æ­£æ–¹å½¢', borderWidth: 50 },
            portrait: { width: 1080, height: 1350, name: 'ç›´å¼', borderWidth: 48 },
            story: { width: 1080, height: 1920, name: 'é™æ™‚å‹•æ…‹', borderWidth: 45 }
        };
        
        let currentFormat = 'square';
        let currentStyle = 'hfp_polaroid';
        
        function createFrame(format) {
            const config = formats[format];
            
            // Set canvas size
            canvas.width = config.width;
            canvas.height = config.height;
            canvasInfo.textContent = `${config.width} Ã— ${config.height} åƒç´ `;
            
            // Clear canvas
            ctx.clearRect(0, 0, config.width, config.height);
            
            // Draw frame based on selected style
            switch(currentStyle) {
                case 'hfp_polaroid':
                    drawHfpPolaroidFrame(ctx, config);
                    break;
                case 'snow-frame':
                    drawSnowFrameFrame(ctx, config);
                    break;
                case 'christmas-ornaments':
                    drawChristmasOrnamentsFrame(ctx, config);
                    break;
                case 'winter-glow':
                    drawWinterGlowFrame(ctx, config);
                    break;
                case 'festive-lights':
                    drawFestiveLightsFrame(ctx, config);
                    break;
                default:
                    drawHollyBorderFrame(ctx, config);
            }
            
            // åŠ å…¥è–èª•ç¥ç¦æ–‡å­—ï¼ˆä¿¡å‹æ‹ç«‹å¾—é¢¨æ ¼é™¤å¤–ï¼‰
            if (currentStyle !== 'hfp_polaroid') {
                drawChristmasText(ctx, config.width, config.height, config.borderWidth, currentStyle);
            }
        }
        
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        function drawChristmasText(ctx, canvasWidth, canvasHeight, borderWidth, style = 'hfp_polaroid') {
            ctx.save();
            
            // è¨ˆç®—æ–‡å­—ä½ç½® (åº•éƒ¨ä¸­å¤®)
            const textY = canvasHeight - borderWidth * 1.4;
            const textX = canvasWidth / 2;
            
            // è¨­å®šè–èª•æ–‡å­—æ¨£å¼
            const fontSize = Math.max(65, borderWidth * 2.2);
            ctx.font = `italic bold ${fontSize}px "Georgia", "Times New Roman", serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // æ ¹æ“šé¢¨æ ¼è¨­å®šæ–‡å­—é¡è‰²å’Œæ•ˆæœ
            let textColor, shadowColor, strokeColor, shadowBlur, shadowOffset;
            
            switch(style) {
                case 'hfp_polaroid':
                    textColor = '#dc2626'; // è–èª•ç´…
                    shadowColor = 'rgba(21, 185, 129, 0.6)';
                    strokeColor = 'rgba(255, 255, 255, 0.9)';
                    shadowBlur = 4;
                    shadowOffset = 2;
                    break;
                    
                case 'snow-frame':
                    textColor = '#1e40af'; // å†°é›ªè—
                    shadowColor = 'rgba(219, 234, 254, 0.8)';
                    strokeColor = 'rgba(255, 255, 255, 0.9)';
                    shadowBlur = 6;
                    shadowOffset = 2;
                    break;
                    
                case 'christmas-ornaments':
                    textColor = '#dc2626'; // è–èª•ç´…
                    shadowColor = 'rgba(21, 185, 129, 0.6)';
                    strokeColor = 'rgba(251, 191, 36, 0.8)';
                    shadowBlur = 4;
                    shadowOffset = 2;
                    break;
                    
                case 'winter-glow':
                    textColor = '#ffffff'; // ç´”ç™½
                    shadowColor = 'rgba(59, 130, 246, 0.8)';
                    strokeColor = 'rgba(21, 185, 129, 0.6)';
                    shadowBlur = 8;
                    shadowOffset = 0;
                    break;
                    
                case 'festive-lights':
                    textColor = '#fbbf24'; // æš–é‡‘è‰²
                    shadowColor = 'rgba(239, 68, 68, 0.6)';
                    strokeColor = 'rgba(21, 185, 129, 0.7)';
                    shadowBlur = 5;
                    shadowOffset = 1;
                    break;
                    
                default:
                    textColor = '#dc2626';
                    shadowColor = 'rgba(21, 185, 129, 0.5)';
                    strokeColor = 'rgba(255, 255, 255, 0.8)';
                    shadowBlur = 3;
                    shadowOffset = 2;
            }
            
            // è¨­å®šæ–‡å­—æ¨£å¼
            ctx.fillStyle = textColor;
            
            // åŠ å…¥æ–‡å­—é™°å½±æ•ˆæœ
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = shadowBlur;
            ctx.shadowOffsetX = shadowOffset;
            ctx.shadowOffsetY = shadowOffset;
            
            // ç¹ªè£½è–èª•ç¥ç¦æ–‡å­—
            ctx.fillText('Merry Christmas!', textX, textY);
            
            // åŠ å…¥æ–‡å­—å¤–æ¡†
            ctx.shadowColor = 'transparent';
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.strokeText('Merry Christmas!', textX, textY);
            
            ctx.restore();
        }
        
        // ğŸ“¸ ä¿¡å‹æ‹ç«‹å¾—é¢¨æ ¼ - å¾©å¤æƒ…æ‡·ï¼ˆç¶“å…¸ç™½é‚Šæ¡†ï¼‰
        function drawHfpPolaroidFrame(ctx, config) {
            ctx.save();
            
            // ç¶“å…¸æ‹ç«‹å¾—æ¯”ä¾‹è¨­è¨ˆ
            // æ ¹æ“šåŸåœ–åˆ†æï¼šä¸Šé‚Šæ¡†å’Œå·¦å³é‚Šæ¡†è¼ƒçª„ï¼Œåº•é‚Šæ¡†å¾ˆå¯¬
            const topSideBorder = config.borderWidth * 0.6;    // ä¸Šé‚Šæ¡†å’Œå·¦å³é‚Šæ¡†ï¼ˆè¼ƒçª„ï¼‰
            const bottomBorder = config.borderWidth * 3.3;     // åº•é‚Šæ¡†ï¼ˆåŠ å¯¬ 1.5 å€ï¼š2.2 * 1.5 = 3.3ï¼‰
            
            // 1. æ•´é«”ç™½è‰²æ‹ç«‹å¾—èƒŒæ™¯
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, config.width, config.height);
            
            // 2. å¤–éƒ¨æ·ºç°è‰²ç´°é‚Šæ¡†ï¼ˆæ¨¡æ“¬å¯¦é«”æ‹ç«‹å¾—çš„é‚Šç·£ï¼‰
            ctx.strokeStyle = '#d1d5db';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, config.width - 2, config.height - 2);
            
            // 3. å…§éƒ¨ç…§ç‰‡å€åŸŸï¼ˆé€æ˜ï¼Œè®“ç”¨æˆ¶ç…§ç‰‡é¡¯ç¤ºï¼‰
            ctx.globalCompositeOperation = 'destination-out';
            const photoX = topSideBorder;
            const photoY = topSideBorder;
            const photoWidth = config.width - 2 * topSideBorder;
            const photoHeight = config.height - topSideBorder - bottomBorder;
            
            // ç…§ç‰‡å€åŸŸæ˜¯ç›´è§’çŸ©å½¢ï¼ˆçœŸå¯¦æ‹ç«‹å¾—é¢¨æ ¼ï¼‰
            ctx.fillRect(photoX, photoY, photoWidth, photoHeight);
            
            // é‡ç½®åˆæˆæ¨¡å¼
            ctx.globalCompositeOperation = 'source-over';
            
            // 4. ç…§ç‰‡å€åŸŸå…§é‚Šæ¡†ï¼ˆæ·ºç°è‰²ç´°ç·šï¼‰
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            ctx.strokeRect(photoX, photoY, photoWidth, photoHeight);
            
            // 5. åº•éƒ¨ LOGO å€åŸŸè¨­è¨ˆ
            drawAuthenticHfpcBranding(ctx, config, bottomBorder);
            
            ctx.restore();
        }
        
        // HfpcTextLayoutModule - æ™ºèƒ½æ–‡å­—ä½ˆå±€ç³»çµ±
        class HfpcTextLayoutModule {
            constructor(ctx, config, bottomBorderWidth) {
                this.ctx = ctx;
                this.config = config;
                this.bottomBorderWidth = bottomBorderWidth;
                
                // åŸºç¤å°ºå¯¸è¨ˆç®—
                this.baseSize = Math.min(bottomBorderWidth * 0.65, 85);
                this.chineseFontSize = this.baseSize * 0.42;
                this.englishFontSize = this.baseSize * 0.26;
                
                // è¨ˆç®—å°é½Šå¯¬åº¦
                this.calculateAlignedWidths();
                
                // å‚ç›´é–“è·ï¼šä½¿ç”¨å‹•æ…‹è¨ˆç®—ç¢ºä¿ä¸é‡ç–Š
                this.lineSpacing = Math.max(this.chineseFontSize * 0.65, 12);
            }
            
            calculateAlignedWidths() {
                // æ¸¬é‡ä¸­æ–‡æ–‡å­—å¯¬åº¦
                this.ctx.font = `bold ${this.chineseFontSize}px "SimHei", "Microsoft YaHei", "é»‘é«”", sans-serif`;
                const chineseWidth = this.ctx.measureText('å°åŒ—ä¿¡å‹å ‚').width;
                
                // æ¸¬é‡è‹±æ–‡æ–‡å­—å¯¬åº¦
                this.ctx.font = `normal ${this.englishFontSize}px "Arial", sans-serif`;
                const englishWidth = this.ctx.measureText('H F P C  C H U R C H').width;
                
                // è¨ˆç®—èª¿æ•´æ¯”ä¾‹ä½¿ä¸­è‹±æ–‡å¯¬åº¦ä¸€è‡´
                const widthRatio = chineseWidth / englishWidth;
                this.adjustedEnglishFontSize = this.englishFontSize * widthRatio;
            }
            
            drawText(x, y) {
                this.ctx.save();
                this.ctx.fillStyle = '#000000';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';
                
                // ç¹ªè£½ä¸­æ–‡
                this.ctx.font = `bold ${this.chineseFontSize}px "SimHei", "Microsoft YaHei", "é»‘é«”", sans-serif`;
                this.ctx.fillText('å°åŒ—ä¿¡å‹å ‚', x, y - this.lineSpacing);
                
                // ç¹ªè£½è‹±æ–‡ï¼ˆä½¿ç”¨èª¿æ•´å¾Œçš„å­—é«”å¤§å°ï¼‰
                this.ctx.font = `normal ${this.adjustedEnglishFontSize}px "Arial", sans-serif`;
                this.ctx.fillText('H F P C  C H U R C H', x, y + this.lineSpacing);
                
                this.ctx.restore();
            }
        }

        // ç¹ªè£½çœŸå¯¦ä¿¡å‹å ‚å“ç‰Œè¨­è¨ˆ
        function drawAuthenticHfpcBranding(ctx, config, bottomBorderWidth) {
            ctx.save();
            
            // LOGO å’Œæ–‡å­—çš„ä½ç½®è¨ˆç®—ï¼ˆé å·¦å°é½Šï¼‰
            const logoY = config.height - bottomBorderWidth * 0.55;
            const logoSize = Math.min(bottomBorderWidth * 0.65, 85);
            const logoX = bottomBorderWidth * 0.25; // é å·¦ä½ç½®
            
            // 1. ç¹ªè£½æ•™å ‚å»ºç¯‰ LOGO
            drawChurchLogo(ctx, logoX, logoY, logoSize);
            
            // 2. ä½¿ç”¨æ™ºèƒ½æ–‡å­—ä½ˆå±€ç³»çµ±
            const textX = logoX + logoSize + 20;
            const textLayoutModule = new HfpcTextLayoutModule(ctx, config, bottomBorderWidth);
            textLayoutModule.drawText(textX, logoY);
            
            ctx.restore();
        }
        
        // ç¹ªè£½ç°¡åŒ–çš„æ•™å ‚å»ºç¯‰åœ–æ¨™
        function drawChurchLogo(ctx, x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            
            // è¨­å®šç¹ªè£½æ¨£å¼
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#000000';
            ctx.lineWidth = size / 30;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // ç¸®æ”¾æ¯”ä¾‹
            const s = size / 100;
            
            // 1. åœ“å½¢å¤–æ¡†
            ctx.beginPath();
            ctx.arc(0, 0, 40 * s, 0, Math.PI * 2);
            ctx.stroke();
            
            // 2. ä¸»æ•™å ‚å»ºç¯‰ï¼ˆç°¡åŒ–ï¼‰
            ctx.beginPath();
            // ä¸»å»ºç¯‰é«”ï¼ˆçŸ©å½¢ï¼‰
            ctx.rect(-25 * s, -10 * s, 50 * s, 35 * s);
            // å°–å¡”å±‹é ‚ï¼ˆä¸‰è§’å½¢ï¼‰
            ctx.moveTo(-25 * s, -10 * s);
            ctx.lineTo(0, -35 * s);
            ctx.lineTo(25 * s, -10 * s);
            ctx.stroke();
            
            // 3. åå­—æ¶
            const crossSize = 8 * s;
            ctx.beginPath();
            // å‚ç›´ç·š
            ctx.moveTo(0, -35 * s);
            ctx.lineTo(0, -35 * s - crossSize);
            // æ°´å¹³ç·š
            ctx.moveTo(-crossSize/2, -35 * s - crossSize * 0.3);
            ctx.lineTo(crossSize/2, -35 * s - crossSize * 0.3);
            ctx.stroke();
            
            // 4. é–€å’Œçª—æˆ¶ç´°ç¯€
            // ä¸»é–€
            ctx.beginPath();
            ctx.rect(-4 * s, 10 * s, 8 * s, 15 * s);
            ctx.stroke();
            
            // çª—æˆ¶
            ctx.beginPath();
            ctx.rect(-15 * s, 0, 6 * s, 8 * s);
            ctx.rect(9 * s, 0, 6 * s, 8 * s);
            ctx.stroke();
            
            ctx.restore();
        }
        
        
        function drawEnhancedHollyDecorations(ctx, config, borderWidth) {
            const positions = [
                {x: borderWidth * 1.5, y: borderWidth * 1.5}, // å·¦ä¸Š
                {x: config.width - borderWidth * 1.5, y: borderWidth * 1.5}, // å³ä¸Š
                {x: borderWidth * 1.5, y: config.height - borderWidth * 1.5}, // å·¦ä¸‹
                {x: config.width - borderWidth * 1.5, y: config.height - borderWidth * 1.5} // å³ä¸‹
            ];
            
            positions.forEach((pos, index) => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate((index * Math.PI) / 6); // ç¨å¾®æ—‹è½‰å¢åŠ å‹•æ„Ÿ
                
                // æ›´å¤§æ›´è±å¯Œçš„å†¬é’è‘‰ - æ¼¸å±¤ç¶ è‰²
                const leafGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                leafGradient.addColorStop(0, '#15b981');
                leafGradient.addColorStop(0.7, '#059669');
                leafGradient.addColorStop(1, '#064e3b');
                
                ctx.fillStyle = leafGradient;
                // ä¸»è¦å†¬é’è‘‰
                ctx.beginPath();
                ctx.ellipse(0, -10, 18, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(-10, 5, 12, 8, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(10, 5, 12, 8, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // é¡å¤–çš„å°è‘‰å­
                ctx.fillStyle = '#16a34a';
                ctx.beginPath();
                ctx.ellipse(-6, -6, 8, 5, Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(6, -6, 8, 5, -Math.PI / 3, 0, Math.PI * 2);
                ctx.fill();
                
                // æ›´å¤šç´…è‰²æ¼¿æœ - å¸¶å…‰æ¾¤
                const berryGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 4);
                berryGradient.addColorStop(0, '#f87171');
                berryGradient.addColorStop(0.6, '#dc2626');
                berryGradient.addColorStop(1, '#7f1d1d');
                
                ctx.fillStyle = berryGradient;
                // æ¼¿æœç¾¤
                ctx.beginPath();
                ctx.arc(-5, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5, 2, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, 8, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-3, 5, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(3, -2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // æ·»åŠ å°æ˜Ÿæ˜Ÿè£é£¾
                ctx.fillStyle = '#fbbf24';
                drawStar(ctx, -12, -12, 3, 5);
                drawStar(ctx, 12, 12, 2, 4);
                
                ctx.restore();
            });
        }
        
        function drawChristmasBells(ctx, config, borderWidth) {
            const bellPositions = [
                {x: config.width / 2, y: borderWidth * 0.7},
                {x: config.width / 2, y: config.height - borderWidth * 0.7},
                {x: borderWidth * 0.7, y: config.height / 2},
                {x: config.width - borderWidth * 0.7, y: config.height / 2}
            ];
            
            bellPositions.forEach(pos => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                
                // éˆ´éºä¸»é«” - é‡‘è‰²æ¼¸è®Š
                const bellGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                bellGradient.addColorStop(0, '#fcd34d');
                bellGradient.addColorStop(0.7, '#f59e0b');
                bellGradient.addColorStop(1, '#d97706');
                
                ctx.fillStyle = bellGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // éˆ´éºé«˜å…‰
                ctx.fillStyle = '#fef3c7';
                ctx.beginPath();
                ctx.arc(-2, -2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // éˆ´éºé ‚éƒ¨
                ctx.fillStyle = '#92400e';
                ctx.fillRect(-2, -8, 4, 3);
                
                // å°éˆ´éºå…§èŠ¯
                ctx.fillStyle = '#78350f';
                ctx.beginPath();
                ctx.arc(0, 2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        function drawStar(ctx, x, y, innerRadius, outerRadius) {
            const spikes = 5;
            let rot = Math.PI / 2 * 3;
            const step = Math.PI / spikes;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();
            ctx.moveTo(0, -outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(Math.cos(rot) * outerRadius, Math.sin(rot) * outerRadius);
                rot += step;
                ctx.lineTo(Math.cos(rot) * innerRadius, Math.sin(rot) * innerRadius);
                rot += step;
            }
            
            ctx.lineTo(0, -outerRadius);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        // â„ï¸ é›ªèŠ±é‚Šæ¡†é¢¨æ ¼ - å†¬æ—¥ç´”ç™½
        function drawSnowFrameFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = borderWidth * 0.4;
            
            // ä¸»é‚Šæ¡† - å†°è—è‰²æ¼¸è®Š
            const gradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            gradient.addColorStop(0, '#dbeafe');    // æ·ºè—
            gradient.addColorStop(0.5, '#bfdbfe');  // ä¸­è—
            gradient.addColorStop(1, '#93c5fd');    // è—è‰²
            
            ctx.save();
            ctx.strokeStyle = gradient;
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§é‚Šæ¡† - ç™½è‰²
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            const innerMargin = borderWidth - 6;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 3);
            ctx.stroke();
            
            // ç¹ªè£½é›ªèŠ±è£é£¾
            drawSnowflakeDecorations(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawSnowflakeDecorations(ctx, config, borderWidth) {
            const snowflakes = [
                {x: borderWidth * 1.5, y: borderWidth * 1.5, size: 0.8},
                {x: config.width - borderWidth * 1.5, y: borderWidth * 1.5, size: 1.0},
                {x: borderWidth * 1.5, y: config.height - borderWidth * 1.5, size: 1.2},
                {x: config.width - borderWidth * 1.5, y: config.height - borderWidth * 1.5, size: 0.9},
                {x: config.width / 2, y: borderWidth, size: 1.1},
                {x: config.width / 2, y: config.height - borderWidth, size: 1.0}
            ];
            
            snowflakes.forEach(flake => {
                ctx.save();
                ctx.translate(flake.x, flake.y);
                ctx.scale(flake.size, flake.size);
                
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                // ç¹ªè£½å…­è§’é›ªèŠ±
                for (let i = 0; i < 6; i++) {
                    ctx.save();
                    ctx.rotate((i * Math.PI) / 3);
                    
                    // ä¸»ç·š
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(0, 12);
                    ctx.stroke();
                    
                    // åˆ†æ”¯
                    ctx.beginPath();
                    ctx.moveTo(-4, -8);
                    ctx.lineTo(0, -12);
                    ctx.lineTo(4, -8);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(-4, 8);
                    ctx.lineTo(0, 12);
                    ctx.lineTo(4, 8);
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                ctx.restore();
            });
        }
        
        // ğŸ„ è–èª•é£¾å“é¢¨æ ¼ - é€æ˜é‚Šæ¡†è£é£¾
        function drawChristmasOrnamentsFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = 12;
            
            ctx.save();
            
            // ä¸»é‚Šæ¡† - è–èª•ç´…ç¶ æ¼¸è®Š (é€æ˜èƒŒæ™¯)
            const borderGradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            borderGradient.addColorStop(0, '#dc2626');
            borderGradient.addColorStop(0.5, '#15b981');
            borderGradient.addColorStop(1, '#dc2626');
            
            ctx.strokeStyle = borderGradient;
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§é‚Šæ¡† - é‡‘è‰²è£é£¾ç·š
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 4;
            const innerMargin = borderWidth - 8;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 2);
            ctx.stroke();
            
            // ç¹ªè£½è§’è½è–èª•é£¾å“
            drawCornerOrnaments(ctx, config, borderWidth);
            
            // ç¹ªè£½é‚Šæ¡†è£é£¾å½©å¸¶
            drawDecorativeGarlands(ctx, config, borderWidth);
            
            // ç¹ªè£½è–èª•éˆ´éºè£é£¾
            drawChristmasBellsOrnaments(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawCornerOrnaments(ctx, config, borderWidth) {
            const ornamentPositions = [
                {x: borderWidth * 1.5, y: borderWidth * 1.5, rotation: 0},
                {x: config.width - borderWidth * 1.5, y: borderWidth * 1.5, rotation: Math.PI / 2},
                {x: borderWidth * 1.5, y: config.height - borderWidth * 1.5, rotation: -Math.PI / 2},
                {x: config.width - borderWidth * 1.5, y: config.height - borderWidth * 1.5, rotation: Math.PI}
            ];
            
            ornamentPositions.forEach((pos, index) => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.rotation);
                
                // è–èª•çƒé£¾å“ - ç´…è‰²
                const redOrnament = ctx.createRadialGradient(0, 0, 0, 0, 0, 18);
                redOrnament.addColorStop(0, '#f87171');
                redOrnament.addColorStop(0.7, '#dc2626');
                redOrnament.addColorStop(1, '#7f1d1d');
                
                ctx.fillStyle = redOrnament;
                ctx.beginPath();
                ctx.arc(-10, 0, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // ç´…è‰²é£¾å“é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(-15, -5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // è–èª•çƒé£¾å“ - ç¶ è‰²
                const greenOrnament = ctx.createRadialGradient(0, 0, 0, 0, 0, 18);
                greenOrnament.addColorStop(0, '#34d399');
                greenOrnament.addColorStop(0.7, '#15b981');
                greenOrnament.addColorStop(1, '#064e3b');
                
                ctx.fillStyle = greenOrnament;
                ctx.beginPath();
                ctx.arc(10, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // ç¶ è‰²é£¾å“é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(5, -4, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // è–èª•çƒé£¾å“ - é‡‘è‰²
                const goldOrnament = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                goldOrnament.addColorStop(0, '#fcd34d');
                goldOrnament.addColorStop(0.7, '#fbbf24');
                goldOrnament.addColorStop(1, '#d97706');
                
                ctx.fillStyle = goldOrnament;
                ctx.beginPath();
                ctx.arc(0, 15, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // é‡‘è‰²é£¾å“é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(-3, 11, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // é£¾å“é ‚éƒ¨é‡‘å±¬æ‰£
                ctx.fillStyle = '#92400e';
                ctx.fillRect(-12, -8, 4, 3);
                ctx.fillRect(8, -6, 4, 3);
                ctx.fillRect(-2, 5, 4, 3);
                
                // æ·»åŠ é–ƒäº®æ˜Ÿæ˜Ÿ
                ctx.fillStyle = '#fbbf24';
                drawStar(ctx, -20, -10, 2, 4);
                drawStar(ctx, 20, 10, 2, 4);
                
                ctx.restore();
            });
        }
        
        function drawDecorativeGarlands(ctx, config, borderWidth) {
            // ä¸Šé‚ŠèŠ±ç’°
            drawGarlandLine(ctx, borderWidth, borderWidth * 0.7, config.width - borderWidth, borderWidth * 0.7);
            
            // ä¸‹é‚ŠèŠ±ç’°
            drawGarlandLine(ctx, borderWidth, config.height - borderWidth * 0.7, config.width - borderWidth, config.height - borderWidth * 0.7);
            
            // å·¦é‚ŠèŠ±ç’°
            drawVerticalGarlandLine(ctx, borderWidth * 0.7, borderWidth, borderWidth * 0.7, config.height - borderWidth);
            
            // å³é‚ŠèŠ±ç’°
            drawVerticalGarlandLine(ctx, config.width - borderWidth * 0.7, borderWidth, config.width - borderWidth * 0.7, config.height - borderWidth);
        }
        
        function drawGarlandLine(ctx, x1, y1, x2, y2) {
            const segmentLength = 40;
            const segments = Math.floor((x2 - x1) / segmentLength);
            
            for (let i = 0; i <= segments; i++) {
                const x = x1 + (i * segmentLength);
                const wave = Math.sin((i * Math.PI) / 3 + Date.now() * 0.002) * 5;
                
                // ç¶ è‰²è‘‰å­
                ctx.fillStyle = '#15b981';
                ctx.beginPath();
                ctx.ellipse(x, y1 + wave, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç´…è‰²å°æœå¯¦
                if (i % 2 === 0) {
                    ctx.fillStyle = '#dc2626';
                    ctx.beginPath();
                    ctx.arc(x + 5, y1 + wave - 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // é‡‘è‰²å°é»ç¶´
                if (i % 3 === 0) {
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(x - 5, y1 + wave + 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawVerticalGarlandLine(ctx, x1, y1, x2, y2) {
            const segmentLength = 40;
            const segments = Math.floor((y2 - y1) / segmentLength);
            
            for (let i = 0; i <= segments; i++) {
                const y = y1 + (i * segmentLength);
                const wave = Math.sin((i * Math.PI) / 3 + Date.now() * 0.002) * 5;
                
                // ç¶ è‰²è‘‰å­
                ctx.fillStyle = '#15b981';
                ctx.beginPath();
                ctx.ellipse(x1 + wave, y, 4, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç´…è‰²å°æœå¯¦
                if (i % 2 === 0) {
                    ctx.fillStyle = '#dc2626';
                    ctx.beginPath();
                    ctx.arc(x1 + wave - 3, y + 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // é‡‘è‰²å°é»ç¶´
                if (i % 3 === 0) {
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(x1 + wave + 3, y - 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawChristmasBellsOrnaments(ctx, config, borderWidth) {
            const bellPositions = [
                {x: config.width / 2, y: borderWidth * 0.6},
                {x: config.width / 2, y: config.height - borderWidth * 0.6},
                {x: borderWidth * 0.6, y: config.height / 2},
                {x: config.width - borderWidth * 0.6, y: config.height / 2}
            ];
            
            bellPositions.forEach((pos, index) => {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                
                const time = Date.now() * 0.003 + index;
                const swing = Math.sin(time) * 0.1;
                ctx.rotate(swing);
                
                // éˆ´éºä¸»é«” - é‡‘è‰²æ¼¸è®Š
                const bellGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 12);
                bellGradient.addColorStop(0, '#fcd34d');
                bellGradient.addColorStop(0.7, '#f59e0b');
                bellGradient.addColorStop(1, '#d97706');
                
                ctx.fillStyle = bellGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // éˆ´éºé«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(-3, -3, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // éˆ´éºé ‚éƒ¨
                ctx.fillStyle = '#92400e';
                ctx.fillRect(-3, -10, 6, 4);
                
                // å°éˆ´éºå…§èŠ¯
                ctx.fillStyle = '#78350f';
                ctx.beginPath();
                ctx.arc(0, 3, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // ç´…è‰²è´è¶çµè£é£¾
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.ellipse(-4, -8, 3, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(4, -8, 3, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(-1, -10, 2, 4);
                
                ctx.restore();
            });
        }
        
        // âœ¨ å†¬æ—¥å…‰æšˆé¢¨æ ¼ - æº«æš–å…‰èŠ’
        function drawWinterGlowFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = borderWidth * 0.5;
            
            // å‰µå»ºå…‰æšˆæ¼¸è®Š
            const glowGradient = ctx.createRadialGradient(
                config.width/2, config.height/2, 0,
                config.width/2, config.height/2, Math.max(config.width, config.height)/2
            );
            glowGradient.addColorStop(0, 'rgba(59, 130, 246, 0.1)');
            glowGradient.addColorStop(0.7, 'rgba(147, 197, 253, 0.3)');
            glowGradient.addColorStop(1, 'rgba(59, 130, 246, 0.6)');
            
            ctx.save();
            
            // å…‰æšˆèƒŒæ™¯
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, config.width, config.height);
            
            // ä¸»é‚Šæ¡†
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 20;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§ç™¼å…‰
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#bfdbfe';
            ctx.strokeStyle = 'rgba(191, 219, 254, 0.6)';
            ctx.lineWidth = 6;
            const innerMargin = borderWidth - 8;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 4);
            ctx.stroke();
            
            // ç¹ªè£½å…‰é»è£é£¾
            drawGlowDecorations(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawGlowDecorations(ctx, config, borderWidth) {
            const lightPositions = [
                {x: borderWidth * 1.2, y: borderWidth * 1.2, size: 8, color: '#3b82f6'},
                {x: config.width - borderWidth * 1.2, y: borderWidth * 1.2, size: 12, color: '#8b5cf6'},
                {x: borderWidth * 1.2, y: config.height - borderWidth * 1.2, size: 10, color: '#06b6d4'},
                {x: config.width - borderWidth * 1.2, y: config.height - borderWidth * 1.2, size: 9, color: '#10b981'},
                {x: config.width/2, y: borderWidth * 0.8, size: 15, color: '#f59e0b'},
                {x: config.width/2, y: config.height - borderWidth * 0.8, size: 11, color: '#ef4444'}
            ];
            
            // æ·»åŠ æ›´å¤šéš¨æ©Ÿå…‰é»
            for (let i = 0; i < 25; i++) {
                const colors = ['#3b82f6', '#8b5cf6', '#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#ec4899'];
                lightPositions.push({
                    x: borderWidth * 2 + Math.random() * (config.width - 4 * borderWidth),
                    y: borderWidth * 2 + Math.random() * (config.height - 4 * borderWidth),
                    size: 3 + Math.random() * 6,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            
            lightPositions.forEach((light, index) => {
                ctx.save();
                
                // å‹•æ…‹äº®åº¦è®ŠåŒ–
                const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.003 + index * 0.5);
                
                // å¤–å±¤å…‰æšˆ
                const outerGlow = ctx.createRadialGradient(
                    light.x, light.y, 0,
                    light.x, light.y, light.size * 4
                );
                outerGlow.addColorStop(0, light.color + Math.floor(pulse * 100).toString(16).padStart(2, '0'));
                outerGlow.addColorStop(0.3, light.color + Math.floor(pulse * 60).toString(16).padStart(2, '0'));
                outerGlow.addColorStop(0.7, light.color + Math.floor(pulse * 30).toString(16).padStart(2, '0'));
                outerGlow.addColorStop(1, light.color + '00');
                
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(light.x, light.y, light.size * 4, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸»ç™¼å…‰é«”
                const mainGlow = ctx.createRadialGradient(
                    light.x, light.y, 0,
                    light.x, light.y, light.size * 2
                );
                mainGlow.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
                mainGlow.addColorStop(0.4, light.color + Math.floor(pulse * 180).toString(16).padStart(2, '0'));
                mainGlow.addColorStop(1, light.color + Math.floor(pulse * 80).toString(16).padStart(2, '0'));
                
                ctx.fillStyle = mainGlow;
                ctx.beginPath();
                ctx.arc(light.x, light.y, light.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸­å¿ƒæ ¸å¿ƒ
                const coreGlow = ctx.createRadialGradient(
                    light.x - light.size/3, light.y - light.size/3, 0,
                    light.x, light.y, light.size
                );
                coreGlow.addColorStop(0, `rgba(255, 255, 255, ${pulse})`);
                coreGlow.addColorStop(0.6, light.color);
                coreGlow.addColorStop(1, light.color + 'AA');
                
                ctx.fillStyle = coreGlow;
                ctx.beginPath();
                ctx.arc(light.x, light.y, light.size, 0, Math.PI * 2);
                ctx.fill();
                
                // é«˜å…‰é»
                ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
                ctx.beginPath();
                ctx.arc(light.x - light.size/3, light.y - light.size/3, light.size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // å…‰ç·šæ•ˆæœ
                if (light.size > 8) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 * pulse})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let ray = 0; ray < 8; ray++) {
                        const angle = (ray * Math.PI * 2) / 8;
                        const startX = light.x + Math.cos(angle) * light.size;
                        const startY = light.y + Math.sin(angle) * light.size;
                        const endX = light.x + Math.cos(angle) * light.size * 3;
                        const endY = light.y + Math.sin(angle) * light.size * 3;
                        
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                    }
                    ctx.stroke();
                }
                
                ctx.restore();
            });
            
            // æ·»åŠ é­”æ³•ç²’å­æ•ˆæœ
            drawMagicParticles(ctx, config);
        }
        
        function drawMagicParticles(ctx, config) {
            const particleColors = ['#fbbf24', '#f472b6', '#a78bfa', '#34d399', '#60a5fa'];
            
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * config.width;
                const y = Math.random() * config.height;
                const time = Date.now() * 0.002 + i;
                const size = 1 + Math.sin(time) * 0.5;
                const alpha = 0.3 + 0.3 * Math.sin(time * 2);
                
                ctx.fillStyle = particleColors[i % particleColors.length] + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ğŸ„ ç¯€æ…¶ç‡ˆé£¾é¢¨æ ¼ - ç¹½ç´›äº®éº—
        function drawFestiveLightsFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = 10;
            
            // ä¸»é‚Šæ¡† - æ·±ç¶ è‰²è–èª•æ¨¹è‰²
            ctx.save();
            ctx.strokeStyle = '#166534';
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            // å…§é‚Šæ¡† - æš–é‡‘è‰²
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 4;
            const innerMargin = borderWidth - 8;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - 2 * innerMargin, config.height - 2 * innerMargin, cornerRadius - 2);
            ctx.stroke();
            
            // ç¹ªè£½å½©ç‡ˆè£é£¾
            drawChristmasLights(ctx, config, borderWidth);
            
            ctx.restore();
        }
        
        function drawChristmasLights(ctx, config, borderWidth) {
            const lightColors = ['#dc2626', '#15b981', '#3b82f6', '#f59e0b', '#8b5cf6', '#ec4899', '#16a34a', '#f97316'];
            const lightSize = 10;
            const spacing = 35;
            
            // ç¹ªè£½ç‡ˆä¸²ç·šæ¢
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 2;
            
            // ä¸Šé‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(borderWidth, borderWidth/2);
            ctx.lineTo(config.width - borderWidth, borderWidth/2);
            ctx.stroke();
            
            // ä¸‹é‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(borderWidth, config.height - borderWidth/2);
            ctx.lineTo(config.width - borderWidth, config.height - borderWidth/2);
            ctx.stroke();
            
            // å·¦é‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(borderWidth/2, borderWidth);
            ctx.lineTo(borderWidth/2, config.height - borderWidth);
            ctx.stroke();
            
            // å³é‚Šç‡ˆä¸²ç·š
            ctx.beginPath();
            ctx.moveTo(config.width - borderWidth/2, borderWidth);
            ctx.lineTo(config.width - borderWidth/2, config.height - borderWidth);
            ctx.stroke();
            
            // ä¸Šé‚Šç‡ˆä¸² - é–ƒçˆæ•ˆæœ
            for (let x = borderWidth + spacing; x < config.width - borderWidth; x += spacing) {
                const colorIndex = Math.floor((x / spacing) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + x * 0.01);
                drawEnhancedChristmasLight(ctx, x, borderWidth/2, lightSize, lightColors[colorIndex], brightness);
            }
            
            // ä¸‹é‚Šç‡ˆä¸²
            for (let x = borderWidth + spacing; x < config.width - borderWidth; x += spacing) {
                const colorIndex = Math.floor((x / spacing + 3) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + x * 0.01 + Math.PI);
                drawEnhancedChristmasLight(ctx, x, config.height - borderWidth/2, lightSize, lightColors[colorIndex], brightness);
            }
            
            // å·¦é‚Šç‡ˆä¸²
            for (let y = borderWidth + spacing; y < config.height - borderWidth; y += spacing) {
                const colorIndex = Math.floor((y / spacing + 1) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + y * 0.01 + Math.PI/2);
                drawEnhancedChristmasLight(ctx, borderWidth/2, y, lightSize, lightColors[colorIndex], brightness);
            }
            
            // å³é‚Šç‡ˆä¸²
            for (let y = borderWidth + spacing; y < config.height - borderWidth; y += spacing) {
                const colorIndex = Math.floor((y / spacing + 4) % lightColors.length);
                const brightness = 0.8 + 0.2 * Math.sin(Date.now() * 0.003 + y * 0.01 + Math.PI * 1.5);
                drawEnhancedChristmasLight(ctx, config.width - borderWidth/2, y, lightSize, lightColors[colorIndex], brightness);
            }
            
            // æ·»åŠ é–ƒäº®çš„æ˜Ÿæ˜Ÿè£é£¾
            drawTwinklingStars(ctx, config, borderWidth);
        }
        
        function drawTwinklingStars(ctx, config, borderWidth) {
            const starPositions = [
                {x: config.width * 0.2, y: config.height * 0.2},
                {x: config.width * 0.8, y: config.height * 0.2},
                {x: config.width * 0.2, y: config.height * 0.8},
                {x: config.width * 0.8, y: config.height * 0.8},
                {x: config.width * 0.5, y: config.height * 0.15},
                {x: config.width * 0.5, y: config.height * 0.85}
            ];
            
            starPositions.forEach((star, index) => {
                const twinkle = 0.5 + 0.5 * Math.sin(Date.now() * 0.005 + index);
                ctx.fillStyle = `rgba(251, 191, 36, ${twinkle})`;
                drawStar(ctx, star.x, star.y, 3, 6);
                
                // æ˜Ÿæ˜Ÿå…‰æšˆ
                const starGlow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, 15);
                starGlow.addColorStop(0, `rgba(251, 191, 36, ${twinkle * 0.3})`);
                starGlow.addColorStop(1, 'rgba(251, 191, 36, 0)');
                
                ctx.fillStyle = starGlow;
                ctx.beginPath();
                ctx.arc(star.x, star.y, 15, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawEnhancedChristmasLight(ctx, x, y, size, color, brightness = 1) {
            ctx.save();
            
            // å¼·åŒ–çš„ç‡ˆæ³¡ç™¼å…‰æ•ˆæœ
            const lightGradient = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
            lightGradient.addColorStop(0, color);
            lightGradient.addColorStop(0.3, color + Math.floor(brightness * 200).toString(16).padStart(2, '0'));
            lightGradient.addColorStop(0.7, color + Math.floor(brightness * 100).toString(16).padStart(2, '0'));
            lightGradient.addColorStop(1, color + '10');
            
            ctx.fillStyle = lightGradient;
            ctx.beginPath();
            ctx.arc(x, y, size * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // ç‡ˆæ³¡å¤–æ®¼ - ç«‹é«”æ•ˆæœ
            const bulbGradient = ctx.createRadialGradient(x - size/3, y - size/3, 0, x, y, size);
            bulbGradient.addColorStop(0, '#ffffff');
            bulbGradient.addColorStop(0.3, color);
            bulbGradient.addColorStop(1, color + 'CC');
            
            ctx.fillStyle = bulbGradient;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // ç‡ˆæ³¡é ‚éƒ¨é‡‘å±¬éƒ¨åˆ†
            ctx.fillStyle = '#4b5563';
            ctx.fillRect(x - size/3, y - size - 3, size * 2/3, 6);
            
            // ç‡ˆæ³¡é«˜å…‰
            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * brightness})`;
            ctx.beginPath();
            ctx.arc(x - size/2, y - size/2, size/2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // å°é«˜å…‰é»
            ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * brightness})`;
            ctx.beginPath();
            ctx.arc(x - size/4, y - size/4, size/6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function switchFormat(format) {
            currentFormat = format;
            
            // Update button states
            document.querySelectorAll('.format-btn[data-format]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.format === format);
            });
            
            createFrame(format);
        }
        
        function switchStyle(style) {
            currentStyle = style;
            
            // Update button states
            document.querySelectorAll('.format-btn[data-style]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.style === style);
            });
            
            createFrame(currentFormat);
        }
        
        function downloadFrame() {
            const config = formats[currentFormat];
            const filename = `frame_${currentFormat}_${currentStyle}_${config.width}x${config.height}.png`;
            
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }
        
        async function downloadAllFrames() {
            const originalFormat = currentFormat;
            const originalStyle = currentStyle;
            
            const styles = ['hfp_polaroid', 'snow-frame', 'christmas-ornaments', 'winter-glow', 'festive-lights'];
            
            for (const [format, config] of Object.entries(formats)) {
                for (const style of styles) {
                    // Switch to specific format and style
                    currentFormat = format;
                    currentStyle = style;
                    createFrame(format);
                    
                    // Wait a bit for rendering
                    await new Promise(resolve => setTimeout(resolve, 150));
                    
                    const filename = `frame_${format}_${style}_${config.width}x${config.height}.png`;
                    
                    canvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }, 'image/png', 1.0);
                    
                    await new Promise(resolve => setTimeout(resolve, 400));
                }
            }
            
            // Restore original format and style
            switchFormat(originalFormat);
            switchStyle(originalStyle);
        }
        
        // Setup event listeners
        document.querySelectorAll('.format-btn[data-format]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                switchFormat(e.currentTarget.dataset.format);
            });
        });
        
        // Style selector event listeners
        document.querySelectorAll('.format-btn[data-style]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                switchStyle(e.currentTarget.dataset.style);
            });
        });
        
        // åŠ å…¥è–èª•éŸ³æ¨‚ä¸»é¡Œè¦–è¦ºå…ƒç´ 
        function addMusicalElements(ctx, config, borderWidth) {
            const notePositions = [
                {x: config.width * 0.15, y: config.height * 0.25, type: 'quarter'},
                {x: config.width * 0.85, y: config.height * 0.3, type: 'eighth'},
                {x: config.width * 0.2, y: config.height * 0.75, type: 'half'},
                {x: config.width * 0.8, y: config.height * 0.7, type: 'quarter'},
                {x: config.width * 0.5, y: config.height * 0.12, type: 'treble'}
            ];
            
            notePositions.forEach((note, index) => {
                ctx.save();
                ctx.translate(note.x, note.y);
                
                const bounce = Math.sin(Date.now() * 0.003 + index) * 3;
                ctx.translate(0, bounce);
                
                // éŸ³ç¬¦é¡è‰²
                const noteColors = ['#fbbf24', '#f87171', '#34d399', '#60a5fa', '#a78bfa'];
                ctx.fillStyle = noteColors[index % noteColors.length];
                
                switch(note.type) {
                    case 'quarter':
                        // å››åˆ†éŸ³ç¬¦
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        ctx.fill();
                        // ç¬¦æ¡¿
                        ctx.fillRect(5, -20, 2, 20);
                        break;
                        
                    case 'eighth':
                        // å…«åˆ†éŸ³ç¬¦
                        ctx.beginPath();
                        ctx.arc(0, 0, 5, 0, Math.PI * 2);
                        ctx.fill();
                        // ç¬¦æ¡¿
                        ctx.fillRect(4, -18, 2, 18);
                        // ç¬¦å°¾
                        ctx.beginPath();
                        ctx.moveTo(6, -18);
                        ctx.quadraticCurveTo(12, -15, 8, -10);
                        ctx.lineTo(6, -12);
                        ctx.fill();
                        break;
                        
                    case 'half':
                        // äºŒåˆ†éŸ³ç¬¦
                        ctx.strokeStyle = noteColors[index % noteColors.length];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        ctx.stroke();
                        // ç¬¦æ¡¿
                        ctx.fillRect(5, -22, 2, 22);
                        break;
                        
                    case 'treble':
                        // é«˜éŸ³è­œè™Ÿ
                        ctx.beginPath();
                        ctx.moveTo(-3, -10);
                        ctx.quadraticCurveTo(-8, -15, -3, -20);
                        ctx.quadraticCurveTo(5, -18, 3, -8);
                        ctx.quadraticCurveTo(8, -5, 3, 0);
                        ctx.quadraticCurveTo(-2, 2, -4, -2);
                        ctx.quadraticCurveTo(-6, -8, -3, -10);
                        ctx.fill();
                        break;
                }
                
                // éŸ³ç¬¦å…‰æšˆ
                const noteGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                noteGlow.addColorStop(0, noteColors[index % noteColors.length] + '40');
                noteGlow.addColorStop(1, noteColors[index % noteColors.length] + '00');
                
                ctx.fillStyle = noteGlow;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
            
            // éŸ³æ¨‚ç·šæ¢æµå‹•æ•ˆæœ
            drawMusicalStaff(ctx, config);
        }
        
        function drawMusicalStaff(ctx, config) {
            const staffY = config.height * 0.1;
            const staffSpacing = 8;
            
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.3)';
            ctx.lineWidth = 1;
            
            // ç¹ªè£½äº”ç·šè­œï¼ˆéƒ¨åˆ†ï¼‰
            for (let i = 0; i < 3; i++) {
                const y = staffY + i * staffSpacing;
                const wave = Math.sin(Date.now() * 0.002 + i) * 5;
                
                ctx.beginPath();
                ctx.moveTo(config.width * 0.1, y + wave);
                
                for (let x = config.width * 0.1; x < config.width * 0.9; x += 10) {
                    const waveY = y + Math.sin((x * 0.02) + Date.now() * 0.002 + i) * 3;
                    ctx.lineTo(x, waveY);
                }
                
                ctx.stroke();
            }
        }
        
        // ä¿®æ”¹ç¾æœ‰çš„é‚Šæ¡†ç¹ªè£½å‡½æ•¸ï¼Œæ·»åŠ éŸ³æ¨‚å…ƒç´ 
        const originalCreateFrame = createFrame;
        createFrame = function(format) {
            originalCreateFrame(format);
            
            // ç‚ºæ‰€æœ‰é¢¨æ ¼æ·»åŠ éŸ³æ¨‚å…ƒç´ 
            const config = formats[format];
            if (currentStyle === 'festive-lights' || currentStyle === 'winter-glow' || currentStyle === 'christmas-ornaments') {
                addMusicalElements(ctx, config, config.borderWidth);
            }
        };
        
        // å¢å¼·å‹•ç•«å¾ªç’°
        function startChristmasAnimation() {
            function animate() {
                if (currentStyle === 'festive-lights' || currentStyle === 'winter-glow' || 
                    currentStyle === 'snow-frame' || currentStyle === 'christmas-ornaments') {
                    createFrame(currentFormat);
                }
                requestAnimationFrame(animate);
            }
            animate();
        }
        
        // Initialize
        createFrame(currentFormat);
        startChristmasAnimation();
        
        // Update todo status
        console.log('ğŸ„ Enhanced Christmas Frame Generator initialized successfully with music and animations!');
    </script>
</body>
</html>