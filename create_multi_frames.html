<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>è‡ªå®šç¾©ç›¸æ¡†ç”Ÿæˆå™¨</title>
    <style>
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            padding: 20px; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin: 0;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 30px; 
            border-radius: 15px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        /* æ¨™é¡Œå€åŸŸ */
        h1 { 
            text-align: center; 
            color: #2c3e50; 
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        /* ä¸»è¦å¸ƒå±€ */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            align-items: start;
        }
        
        /* æ§åˆ¶é¢æ¿æ¨£å¼ */
        .control-panel {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }
        
        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .section h3 { 
            color: #495057; 
            font-size: 18px; 
            margin-bottom: 15px; 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section-icon {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }
        
        /* æŒ‰éˆ•æ¨£å¼ */
        .format-btn { 
            padding: 12px 20px; 
            margin: 5px; 
            border: 2px solid #dee2e6; 
            background: white; 
            color: #495057; 
            cursor: pointer; 
            border-radius: 8px; 
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .format-btn.active { 
            border-color: #007bff; 
            background: #007bff; 
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }
        .format-btn:hover:not(.active) {
            border-color: #007bff;
            background: #f8f9ff;
            color: #007bff;
            transform: translateY(-1px);
        }
        
        /* è¼¸å…¥æ§ä»¶æ¨£å¼ */
        .input-group {
            margin: 15px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }
        
        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }
        
        .input-group input:focus, .input-group select:focus, .input-group textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }
        
        .input-group textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }
        
        /* æ»‘æ¡¿æ¨£å¼ */
        .slider-group {
            margin: 15px 0;
        }
        
        .slider-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }
        
        .slider-value {
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            min-width: 40px;
            text-align: center;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,123,255,0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,123,255,0.3);
        }
        
        /* é¡è‰²é¸æ“‡å™¨æ¨£å¼ */
        .color-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        input[type="color"] {
            width: 60px;
            height: 40px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            background: none;
        }
        
        .color-presets {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        
        .color-preset {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #dee2e6;
            transition: transform 0.2s ease;
        }
        
        .color-preset:hover {
            transform: scale(1.1);
        }
        
        /* é è¦½å€åŸŸ */
        .preview-area {
            text-align: center;
        }
        
        canvas { 
            border: 3px solid #dee2e6; 
            border-radius: 12px;
            max-width: 100%;
            height: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .canvas-info { 
            margin: 15px 0; 
            font-size: 14px; 
            color: #6c757d;
            font-weight: 500;
        }
        
        /* å‹•ä½œæŒ‰éˆ• */
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #1e7e34;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40,167,69,0.3);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
            transform: translateY(-2px);
        }
        
        /* æª”æ¡ˆä¸Šå‚³å€åŸŸ */
        .upload-area {
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 15px 0;
        }
        
        .upload-area:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }
        
        .upload-area.dragover {
            border-color: #007bff;
            background: #f0f8ff;
        }
        
        .upload-icon {
            font-size: 48px;
            color: #6c757d;
            margin-bottom: 10px;
        }
        
        .image-preview {
            max-width: 100%;
            max-height: 120px;
            border-radius: 6px;
            margin: 10px 0;
        }
        
        /* å¤šåœ–ç‰‡ç®¡ç†é¢æ¿æ¨£å¼ */
        .image-manager {
            margin: 15px 0;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            background: #fafafa;
        }
        
        .image-manager-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .image-manager-header h4 {
            margin: 0;
            color: #495057;
            font-size: 14px;
        }
        
        .image-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .image-item {
            position: relative;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }
        
        .image-item:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.15);
        }
        
        .image-item.selected {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        
        .image-item img {
            width: 100%;
            height: 80px;
            object-fit: cover;
            display: block;
        }
        
        .image-item-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 3px;
        }
        
        .image-item-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .image-item-btn.delete {
            background: rgba(220, 53, 69, 0.8);
            color: white;
        }
        
        .image-item-btn.delete:hover {
            background: #dc3545;
        }
        
        .image-item-btn.up {
            background: rgba(40, 167, 69, 0.8);
            color: white;
        }
        
        .image-item-btn.up:hover {
            background: #28a745;
        }
        
        .image-item-btn.down {
            background: rgba(255, 193, 7, 0.8);
            color: black;
        }
        
        .image-item-btn.down:hover {
            background: #ffc107;
        }
        
        .image-item-info {
            padding: 5px;
            font-size: 11px;
            color: #6c757d;
            background: rgba(255,255,255,0.95);
            text-align: center;
        }
        
        .image-item-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* é–‹é—œæ¨£å¼ */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #007bff;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        /* Checkbox æ¨£å¼ä¿®å¾© */
        .checkbox-label {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
            margin-bottom: 8px !important;
            font-weight: 600 !important;
            color: #495057 !important;
            font-size: 14px !important;
            cursor: pointer !important;
        }
        
        .checkbox-label input[type="checkbox"] {
            width: 18px !important;
            height: 18px !important;
            margin: 0 !important;
            cursor: pointer !important;
            accent-color: #007bff !important;
        }
        
        .checkbox-text {
            line-height: 1 !important;
            user-select: none !important;
        }
        
        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
        
        /* ä½¿ç”¨èªªæ˜ */
        .info { 
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); 
            padding: 20px; 
            border-radius: 12px; 
            margin: 30px 0; 
            border-left: 4px solid #007bff;
        }
        
        .info h4 {
            color: #007bff;
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .info ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .info li {
            margin: 5px 0;
            color: #495057;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ è‡ªå®šç¾©ç›¸æ¡†ç”Ÿæˆå™¨</h1>
        
        <div class="main-layout">
            <!-- é è¦½å€åŸŸ -->
            <div class="preview-area">
                <canvas id="frameCanvas"></canvas>
                <div class="canvas-info" id="canvasInfo">1080 Ã— 1080 åƒç´ </div>
                
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="downloadFrame()">
                        ğŸ“¥ ä¸‹è¼‰ç•¶å‰ç›¸æ¡†
                    </button>
                    <button class="btn btn-success" onclick="downloadAllFrames()">
                        ğŸ“¦ ä¸‹è¼‰æ‰€æœ‰æ ¼å¼
                    </button>
                    <button class="btn btn-secondary" onclick="resetAll()">
                        ğŸ”„ é‡ç½®æ‰€æœ‰è¨­å®š
                    </button>
                </div>
            </div>
            
            <!-- æ§åˆ¶é¢æ¿ -->
            <div class="control-panel">
                <!-- æ ¼å¼é¸æ“‡ -->
                <div class="section">
                    <h3>
                        ğŸ“ è¼¸å‡ºæ ¼å¼
                    </h3>
                    <button class="format-btn active" data-format="square">
                        ğŸ“± æ­£æ–¹å½¢ (1080Ã—1080)
                    </button>
                    <button class="format-btn" data-format="portrait">
                        ğŸ“± ç›´å¼ (1080Ã—1350)
                    </button>
                    <button class="format-btn" data-format="story">
                        ğŸ“± é™æ™‚å‹•æ…‹ (1080Ã—1920)
                    </button>
                </div>
                
                <!-- è—è¡“é¢¨æ ¼ -->
                <div class="section">
                    <h3>
                        ğŸ¨ é‚Šæ¡†é¢¨æ ¼
                    </h3>
                    <button class="format-btn active" data-style="modern-gallery">
                        ğŸ–¼ï¸ ç¾ä»£ç•«å»Š
                    </button>
                    <button class="format-btn" data-style="gradient-glow">
                        âœ¨ æ¼¸è®Šå…‰æšˆ
                    </button>
                    <button class="format-btn" data-style="geometric-art">
                        ğŸ”¶ å¹¾ä½•æŠ½è±¡
                    </button>
                    <button class="format-btn" data-style="minimal-lines">
                        â– æ¥µç°¡ç·šæ¢
                    </button>
                    <button class="format-btn" data-style="tech-modern">
                        ğŸ’» ç§‘æŠ€ç¾ä»£
                    </button>
                </div>
                
                <!-- æ–‡å­—è¨­å®š -->
                <div class="section">
                    <h3>
                        âœï¸ æ–‡å­—è¨­å®š
                    </h3>
                    
                    <div class="input-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enableText" checked>
                            <span class="checkbox-text">å•Ÿç”¨æ–‡å­—</span>
                        </label>
                    </div>
                    
                    <div id="textControls">
                        <div class="input-group">
                            <label for="customText">è‡ªå®šç¾©æ–‡å­—</label>
                            <textarea id="customText" placeholder="è¼¸å…¥æ‚¨çš„æ–‡å­—..."></textarea>
                        </div>
                        
                        <div class="input-group">
                            <label for="fontFamily">å­—é«”</label>
                            <select id="fontFamily">
                                <option value="cursive">è‰å¯«é«”</option>
                                <option value="serif">æ¨™æ¥·é«”</option>
                                <option value="sans-serif">å¾®è»Ÿæ­£é»‘é«”</option>
                                <option value="monospace">ç­‰å¯¬å­—é«”</option>
                                <option value="fantasy">è—è¡“å­—é«”</option>
                            </select>
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                å­—é«”å¤§å°
                                <span class="slider-value" id="fontSizeValue">72px</span>
                            </label>
                            <input type="range" id="fontSize" min="16" max="200" value="72">
                        </div>
                        
                        <div class="input-group">
                            <label for="textColor">æ–‡å­—é¡è‰²</label>
                            <div class="color-group">
                                <input type="color" id="textColor" value="#FFD700">
                                <div class="color-presets">
                                    <div class="color-preset" style="background: #FFD700" data-color="#FFD700"></div>
                                    <div class="color-preset" style="background: #FF6B35" data-color="#FF6B35"></div>
                                    <div class="color-preset" style="background: #FFFFFF" data-color="#FFFFFF"></div>
                                    <div class="color-preset" style="background: #000000" data-color="#000000"></div>
                                    <div class="color-preset" style="background: #007BFF" data-color="#007BFF"></div>
                                    <div class="color-preset" style="background: #28A745" data-color="#28A745"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label for="shadowColor">é™°å½±é¡è‰²</label>
                            <input type="color" id="shadowColor" value="#000000">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                é™°å½±æ¨¡ç³Š
                                <span class="slider-value" id="shadowBlurValue">3px</span>
                            </label>
                            <input type="range" id="shadowBlur" min="0" max="20" value="3">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                æ–‡å­—è§’åº¦
                                <span class="slider-value" id="textRotationValue">0Â°</span>
                            </label>
                            <input type="range" id="textRotation" min="-45" max="45" value="0">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                æ°´å¹³ä½ç½®
                                <span class="slider-value" id="textPositionXValue">50%</span>
                            </label>
                            <input type="range" id="textPositionX" min="10" max="90" value="50">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                å‚ç›´ä½ç½®
                                <span class="slider-value" id="textPositionYValue">85%</span>
                            </label>
                            <input type="range" id="textPositionY" min="10" max="90" value="85">
                        </div>
                    </div>
                </div>
                
                <!-- åœ–ç‰‡è¨­å®š -->
                <div class="section">
                    <h3>
                        ğŸ–¼ï¸ åœ–ç‰‡è¨­å®š
                    </h3>
                    
                    <div class="input-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="enableImage">
                            <span class="checkbox-text">å•Ÿç”¨åœ–ç‰‡</span>
                        </label>
                    </div>
                    
                    <div id="imageControls" style="display: none;">
                        <div class="upload-area" id="uploadArea">
                            <div class="upload-icon">ğŸ“</div>
                            <p>é»æ“Šæˆ–æ‹–æ‹½ä¸Šå‚³åœ–ç‰‡</p>
                            <p style="font-size: 12px; color: #6c757d;">æ”¯æ´ PNG, JPG æ ¼å¼ï¼Œå¯åŒæ™‚é¸æ“‡å¤šå¼µ</p>
                            <input type="file" id="imageUpload" accept="image/*" multiple style="display: none;">
                        </div>
                        
                        <!-- å¤šåœ–ç‰‡ç®¡ç†é¢æ¿ -->
                        <div id="imageManager" class="image-manager" style="display: none;">
                            <div class="image-manager-header">
                                <h4>å·²ä¸Šå‚³åœ–ç‰‡ (<span id="imageCount">0</span>)</h4>
                                <button type="button" class="btn-secondary" id="addMoreImages">+ æ–°å¢åœ–ç‰‡</button>
                            </div>
                            <div id="imageList" class="image-list"></div>
                        </div>
                        
                        <!-- å–®å¼µåœ–ç‰‡é è¦½ï¼ˆä¿ç•™å‘ä¸‹ç›¸å®¹ï¼‰ -->
                        <img id="imagePreview" class="image-preview" style="display: none;">
                        
                        <!-- é¸ä¸­åœ–ç‰‡çš„æ§åˆ¶é … -->
                        <div id="selectedImageControls" style="display: none;">
                            <h4>ç·¨è¼¯åœ–ç‰‡: <span id="selectedImageName"></span></h4>
                        
                        <div class="slider-group">
                            <label>
                                åœ–ç‰‡å¤§å°
                                <span class="slider-value" id="imageSizeValue">100%</span>
                            </label>
                            <input type="range" id="imageSize" min="10" max="200" value="100">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                é€æ˜åº¦
                                <span class="slider-value" id="imageOpacityValue">100%</span>
                            </label>
                            <input type="range" id="imageOpacity" min="0" max="100" value="100">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                æ—‹è½‰è§’åº¦
                                <span class="slider-value" id="imageRotationValue">0Â°</span>
                            </label>
                            <input type="range" id="imageRotation" min="-180" max="180" value="0">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                æ°´å¹³ä½ç½®
                                <span class="slider-value" id="imagePositionXValue">50%</span>
                            </label>
                            <input type="range" id="imagePositionX" min="0" max="100" value="50">
                        </div>
                        
                        <div class="slider-group">
                            <label>
                                å‚ç›´ä½ç½®
                                <span class="slider-value" id="imagePositionYValue">20%</span>
                            </label>
                            <input type="range" id="imagePositionY" min="0" max="100" value="20">
                        </div>
                        
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="imageBehindText">
                                åœ–ç‰‡ç½®æ–¼æ–‡å­—å¾Œæ–¹
                            </label>
                        </div>
                        </div> <!-- é—œé–‰ selectedImageControls -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info">
            <h4>âœ¨ ä½¿ç”¨èªªæ˜</h4>
            <ul>
                <li>é¸æ“‡è¼¸å‡ºæ ¼å¼å’Œé‚Šæ¡†é¢¨æ ¼</li>
                <li>å•Ÿç”¨æ–‡å­—åŠŸèƒ½ä¸¦è¼¸å…¥è‡ªå®šç¾©å…§å®¹</li>
                <li>ä¸Šå‚³åœ–ç‰‡ä¸¦èª¿æ•´ä½ç½®ã€å¤§å°ç­‰å±¬æ€§</li>
                <li><strong>ğŸ–±ï¸ æ¡Œé¢ç‰ˆè§’è½æ§åˆ¶ï¼š</strong>æ»‘é¼ æ‡¸åœåœ¨æ–‡å­—/åœ–ç‰‡è§’è½é¡¯ç¤ºè—è‰²æ§åˆ¶é»</li>
                <li><strong>ğŸ“ æ‹–æ‹½èª¿æ•´ï¼š</strong>æ‹–æ‹½è§’è½æ§åˆ¶é»èª¿æ•´å¤§å°</li>
                <li><strong>ğŸ”„ æ—‹è½‰æ¨¡å¼ï¼š</strong>æŒ‰ä½ Alt éµï¼Œè§’è½æ§åˆ¶é»è®Šæˆæ©™è‰²ï¼Œæ‹–æ‹½é€²è¡Œæ—‹è½‰</li>
                <li><strong>ğŸ¯ ç›´è§€æ“ä½œï¼š</strong>ä¸åŒè§’è½æœ‰å°æ‡‰çš„èª¿æ•´å¤§å°æ¸¸æ¨™ï¼ˆâ†– â†— â†™ â†˜ï¼‰</li>
                <li>å³æ™‚é è¦½æ•ˆæœï¼Œæ»¿æ„å¾Œä¸‹è¼‰ PNG æª”æ¡ˆ</li>
                <li>æ”¯æ´æ‰¹æ¬¡ä¸‹è¼‰æ‰€æœ‰æ ¼å¼</li>
                <li>æª”æ¡ˆå‘½åæ ¼å¼ï¼šcustom_frame_[format]_[width]x[height].png</li>
            </ul>
        </div>
    </div>
    
    <script>
        // Canvas å’ŒåŸºæœ¬è¨­å®š
        const canvas = document.getElementById('frameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasInfo = document.getElementById('canvasInfo');
        
        // æ ¼å¼é…ç½®
        const formats = {
            square: { width: 1080, height: 1080, name: 'æ­£æ–¹å½¢', borderWidth: 45 },
            portrait: { width: 1080, height: 1350, name: 'ç›´å¼', borderWidth: 42 },
            story: { width: 1080, height: 1920, name: 'é™æ™‚å‹•æ…‹', borderWidth: 40 }
        };
        
        // å…¨å±€ç‹€æ…‹
        let currentFormat = 'square';
        let currentStyle = 'modern-gallery';
        let uploadedImage = null; // ä¿ç•™å‘ä¸‹ç›¸å®¹
        
        // å¤šåœ–ç‰‡ç®¡ç†ç³»çµ±
        let uploadedImages = []; // å¤šåœ–ç‰‡é™£åˆ—
        let selectedImageIndex = -1; // é¸ä¸­çš„åœ–ç‰‡ç´¢å¼•
        
        // UI å…ƒç´ å¼•ç”¨
        const elements = {
            // æ–‡å­—æ§åˆ¶
            enableText: document.getElementById('enableText'),
            textControls: document.getElementById('textControls'),
            customText: document.getElementById('customText'),
            fontFamily: document.getElementById('fontFamily'),
            fontSize: document.getElementById('fontSize'),
            fontSizeValue: document.getElementById('fontSizeValue'),
            textColor: document.getElementById('textColor'),
            shadowColor: document.getElementById('shadowColor'),
            shadowBlur: document.getElementById('shadowBlur'),
            shadowBlurValue: document.getElementById('shadowBlurValue'),
            textRotation: document.getElementById('textRotation'),
            textRotationValue: document.getElementById('textRotationValue'),
            textPositionX: document.getElementById('textPositionX'),
            textPositionXValue: document.getElementById('textPositionXValue'),
            textPositionY: document.getElementById('textPositionY'),
            textPositionYValue: document.getElementById('textPositionYValue'),
            
            // åœ–ç‰‡æ§åˆ¶
            enableImage: document.getElementById('enableImage'),
            imageControls: document.getElementById('imageControls'),
            uploadArea: document.getElementById('uploadArea'),
            imageUpload: document.getElementById('imageUpload'),
            imagePreview: document.getElementById('imagePreview'),
            imageSize: document.getElementById('imageSize'),
            imageSizeValue: document.getElementById('imageSizeValue'),
            imageOpacity: document.getElementById('imageOpacity'),
            imageOpacityValue: document.getElementById('imageOpacityValue'),
            imageRotation: document.getElementById('imageRotation'),
            imageRotationValue: document.getElementById('imageRotationValue'),
            imagePositionX: document.getElementById('imagePositionX'),
            imagePositionXValue: document.getElementById('imagePositionXValue'),
            imagePositionY: document.getElementById('imagePositionY'),
            imagePositionYValue: document.getElementById('imagePositionYValue'),
            imageBehindText: document.getElementById('imageBehindText'),
            
            // å¤šåœ–ç‰‡ç®¡ç†å…ƒç´ 
            imageManager: document.getElementById('imageManager'),
            imageCount: document.getElementById('imageCount'),
            imageList: document.getElementById('imageList'),
            addMoreImages: document.getElementById('addMoreImages'),
            selectedImageControls: document.getElementById('selectedImageControls'),
            selectedImageName: document.getElementById('selectedImageName')
        };
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            createFrame(currentFormat);
        });
        
        // è¨­å®šæ‰€æœ‰äº‹ä»¶ç›£è½å™¨
        function initializeEventListeners() {
            // æ ¼å¼é¸æ“‡æŒ‰éˆ•
            document.querySelectorAll('[data-format]').forEach(btn => {
                btn.addEventListener('click', function() {
                    // ç§»é™¤å…¶ä»–æŒ‰éˆ•çš„ active é¡
                    document.querySelectorAll('[data-format]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentFormat = this.dataset.format;
                    createFrame(currentFormat);
                });
            });
            
            // é¢¨æ ¼é¸æ“‡æŒ‰éˆ•
            document.querySelectorAll('[data-style]').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('[data-style]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentStyle = this.dataset.style;
                    createFrame(currentFormat);
                });
            });
            
            // æ–‡å­—æ§åˆ¶
            elements.enableText.addEventListener('change', function() {
                elements.textControls.style.display = this.checked ? 'block' : 'none';
                createFrame(currentFormat);
            });
            
            elements.customText.addEventListener('input', () => createFrame(currentFormat));
            elements.fontFamily.addEventListener('change', () => createFrame(currentFormat));
            
            // æ»‘æ¡¿æ§åˆ¶
            setupSlider('fontSize', 'fontSizeValue', 'px');
            setupSlider('shadowBlur', 'shadowBlurValue', 'px');
            setupSlider('textRotation', 'textRotationValue', 'Â°');
            setupSlider('textPositionX', 'textPositionXValue', '%');
            setupSlider('textPositionY', 'textPositionYValue', '%');
            
            // é¡è‰²æ§åˆ¶
            elements.textColor.addEventListener('change', () => createFrame(currentFormat));
            elements.shadowColor.addEventListener('change', () => createFrame(currentFormat));
            
            // é¡è‰²é è¨­æŒ‰éˆ•
            document.querySelectorAll('.color-preset').forEach(preset => {
                preset.addEventListener('click', function() {
                    const color = this.dataset.color;
                    elements.textColor.value = color;
                    createFrame(currentFormat);
                });
            });
            
            // åœ–ç‰‡æ§åˆ¶
            elements.enableImage.addEventListener('change', function() {
                elements.imageControls.style.display = this.checked ? 'block' : 'none';
                createFrame(currentFormat);
            });
            
            // åœ–ç‰‡ä¸Šå‚³
            elements.uploadArea.addEventListener('click', () => elements.imageUpload.click());
            elements.imageUpload.addEventListener('change', handleImageUpload);
            
            // æ‹–æ‹½ä¸Šå‚³
            elements.uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('dragover');
            });
            
            elements.uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                this.classList.remove('dragover');
            });
            
            elements.uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
                if (files.length > 0) {
                    if (files.length === 1) {
                        handleImageFile(files[0]);
                    } else {
                        handleMultipleImageFiles(files);
                    }
                }
            });
            
            // åœ–ç‰‡æ§åˆ¶æ»‘æ¡¿ï¼ˆæ”¯æ´å¤šåœ–ç‰‡ï¼‰
            setupImageSlider('imageSize', 'imageSizeValue', '%');
            setupImageSlider('imageOpacity', 'imageOpacityValue', '%');
            setupImageSlider('imageRotation', 'imageRotationValue', 'Â°');
            setupImageSlider('imagePositionX', 'imagePositionXValue', '%');
            setupImageSlider('imagePositionY', 'imagePositionYValue', '%');
            
            elements.imageBehindText.addEventListener('change', () => {
                // æ›´æ–°é¸ä¸­åœ–ç‰‡çš„è¨­å®š
                if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                    uploadedImages[selectedImageIndex].behindText = elements.imageBehindText.checked;
                }
                createFrame(currentFormat);
            });
            
            // å¤šåœ–ç‰‡ç®¡ç†äº‹ä»¶
            elements.addMoreImages.addEventListener('click', () => elements.imageUpload.click());
            
            // ç•«å¸ƒç›´æ¥æ‹–æ›³åŠŸèƒ½
            setupCanvasDragging();
        }
        
        // å…¨å±€è®Šæ•¸ï¼ˆå¤šåœ–ç‰‡æ‹–æ‹½ç³»çµ±ï¼‰
        let isAltPressed = false;
        
        // å–å¾—å…ƒç´ é‚Šç•Œï¼ˆæ”¯æ´å¤šåœ–ç‰‡ï¼‰
        function getElementBounds(elementType) {
            const config = formats[currentFormat];
            
            if (elementType === 'text' && elements.enableText.checked && elements.customText.value.trim()) {
                const size = parseInt(elements.fontSize.value);
                const posX = (parseInt(elements.textPositionX.value) / 100) * config.width;
                const posY = (parseInt(elements.textPositionY.value) / 100) * config.height;
                
                // ä½¿ç”¨å’Œ drawTextBoundingBox ç›¸åŒçš„è¨ˆç®—é‚è¼¯
                ctx.save();
                let fontFamily = elements.fontFamily.value;
                if (fontFamily === 'cursive') {
                    fontFamily = '"Brush Script MT", "Lucida Handwriting", "Apple Chancery", cursive';
                }
                ctx.font = `${size}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // è¨ˆç®—å¤šè¡Œæ–‡å­—çš„ç¸½å°ºå¯¸
                const text = elements.customText.value.trim();
                const lines = text.split('\n');
                const lineHeight = size * 1.2;
                let maxWidth = 0;
                
                lines.forEach(line => {
                    const metrics = ctx.measureText(line);
                    maxWidth = Math.max(maxWidth, metrics.width);
                });
                
                const totalHeight = lines.length * lineHeight;
                const padding = size * 0.1;
                
                const textWidth = maxWidth + (padding * 2);
                const textHeight = totalHeight + (padding * 2);
                
                ctx.restore();
                
                return {
                    centerX: posX,
                    centerY: posY,
                    left: posX - textWidth / 2,
                    right: posX + textWidth / 2,
                    top: posY - textHeight / 2,
                    bottom: posY + textHeight / 2,
                    width: textWidth,
                    height: textHeight
                };
            }
            
            if (elementType === 'image' && elements.enableImage.checked) {
                // å„ªå…ˆä½¿ç”¨å¤šåœ–ç‰‡ç³»çµ±
                if (uploadedImages.length > 0 && selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                    const imageData = uploadedImages[selectedImageIndex];
                    const imageX = (imageData.positionX / 100) * config.width;
                    const imageY = (imageData.positionY / 100) * config.height;
                    const imageSize = imageData.size / 100;
                    
                    const maxSize = Math.min(config.width, config.height) * 0.8;
                    const scale = (maxSize * imageSize) / Math.max(imageData.image.width, imageData.image.height);
                    const drawWidth = imageData.image.width * scale;
                    const drawHeight = imageData.image.height * scale;
                    
                    return {
                        centerX: imageX,
                        centerY: imageY,
                        left: imageX - drawWidth / 2,
                        right: imageX + drawWidth / 2,
                        top: imageY - drawHeight / 2,
                        bottom: imageY + drawHeight / 2,
                        width: drawWidth,
                        height: drawHeight
                    };
                }
                // å›é€€åˆ°å–®åœ–ç‰‡ç³»çµ±
                else if (uploadedImage) {
                    const imageX = (elements.imagePositionX.value / 100) * config.width;
                    const imageY = (elements.imagePositionY.value / 100) * config.height;
                    const imageSize = elements.imageSize.value / 100;
                    
                    const maxSize = Math.min(config.width, config.height) * 0.8;
                    const scale = (maxSize * imageSize) / Math.max(uploadedImage.width, uploadedImage.height);
                    const drawWidth = uploadedImage.width * scale;
                    const drawHeight = uploadedImage.height * scale;
                    
                    return {
                        centerX: imageX,
                        centerY: imageY,
                        left: imageX - drawWidth / 2,
                        right: imageX + drawWidth / 2,
                        top: imageY - drawHeight / 2,
                        bottom: imageY + drawHeight / 2,
                        width: drawWidth,
                        height: drawHeight
                    };
                }
            }
            
            return null;
        }
        
        // ç¹ªè£½è§’è½æ§åˆ¶é»
        function drawCornerHandles(elementType) {
            const bounds = getElementBounds(elementType);
            if (!bounds) return;
            
            const handleSize = 8;
            const corners = [
                { id: 'tl', x: bounds.left, y: bounds.top },
                { id: 'tr', x: bounds.right, y: bounds.top },
                { id: 'bl', x: bounds.left, y: bounds.bottom },
                { id: 'br', x: bounds.right, y: bounds.bottom }
            ];
            
            ctx.save();
            
            corners.forEach(corner => {
                // ç¹ªè£½æ§åˆ¶é»èƒŒæ™¯
                const fillColor = isAltPressed ? '#ff6b35' : '#007bff';
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.arc(corner.x, corner.y, handleSize, 0, 2 * Math.PI);
                ctx.fill();
                
                // ç¹ªè£½ç™½è‰²é‚Šæ¡†
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç¹ªè£½æ—‹è½‰åœ–ç¤ºï¼ˆç•¶ Alt æŒ‰ä¸‹æ™‚ï¼‰
                if (isAltPressed) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(corner.x, corner.y, handleSize * 0.5, 0, Math.PI * 1.5);
                    ctx.stroke();
                    
                    // ç®­é ­
                    ctx.beginPath();
                    ctx.moveTo(corner.x - handleSize * 0.3, corner.y - handleSize * 0.5);
                    ctx.lineTo(corner.x - handleSize * 0.1, corner.y - handleSize * 0.7);
                    ctx.lineTo(corner.x - handleSize * 0.1, corner.y - handleSize * 0.3);
                    ctx.fill();
                }
            });
            
            ctx.restore();
        }

        // ç•«å¸ƒæ‹–æ›³åŠŸèƒ½è¨­å®š
        function setupCanvasDragging() {
            const canvas = document.getElementById('frameCanvas');
            let isDragging = false;
            let dragTarget = null; // 'text' æˆ– 'image'
            let dragStartX, dragStartY;
            let initialTextX, initialTextY, initialImageX, initialImageY;
            
            // å¤šé»è§¸æ§è®Šæ•¸
            let isMultiTouch = false;
            let touchStartDistance = 0;
            let touchStartAngle = 0;
            let initialScale = 1;
            let initialRotation = 0;
            
            // æ¡Œé¢æ»‘é¼ æ§åˆ¶è®Šæ•¸
            let isScaling = false;
            let isRotating = false;
            let lastMouseY = 0;
            let lastMouseX = 0;
            
            // è§’è½æ§åˆ¶ç³»çµ±è®Šæ•¸
            let isCornerDragging = false;
            let activeCorner = null; // 'tl', 'tr', 'bl', 'br'
            let cornerMode = 'resize'; // 'resize' æˆ– 'rotate'
            let cornerHandles = [];
            let isAltPressed = false;
            
            // éµç›¤ç‹€æ…‹è¿½è¹¤
            document.addEventListener('keydown', function(e) {
                if (e.altKey) {
                    isAltPressed = true;
                    updateCornerVisuals();
                }
            });
            
            document.addEventListener('keyup', function(e) {
                if (!e.altKey) {
                    isAltPressed = false;
                    updateCornerVisuals();
                }
            });
            
            // å–å¾—æ»‘é¼ /è§¸æ§ä½ç½®ç›¸å°æ–¼ç•«å¸ƒçš„åº§æ¨™
            function getCanvasPosition(e, canvas) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                return {
                    x: (clientX - rect.left) * (canvas.width / rect.width),
                    y: (clientY - rect.top) * (canvas.height / rect.height)
                };
            }
            
            // è¨ˆç®—å…©é»é–“è·é›¢
            function getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // è¨ˆç®—å…©é»é–“è§’åº¦
            function getAngle(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.atan2(dy, dx);
            }
            
            // å–å¾—è§¸æ§ä¸­å¿ƒé»
            function getTouchCenter(touch1, touch2) {
                const rect = canvas.getBoundingClientRect();
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                
                return {
                    x: (centerX - rect.left) * (canvas.width / rect.width),
                    y: (centerY - rect.top) * (canvas.height / rect.height)
                };
            }
            
            
            // æª¢æ¸¬æ»‘é¼ æ˜¯å¦åœ¨è§’è½æ§åˆ¶é»ä¸Š
            function detectCornerHandle(canvasX, canvasY, elementType) {
                const bounds = getElementBounds(elementType);
                if (!bounds) return null;
                
                const handleSize = 12;
                const corners = [
                    { id: 'tl', x: bounds.left, y: bounds.top },
                    { id: 'tr', x: bounds.right, y: bounds.top },
                    { id: 'bl', x: bounds.left, y: bounds.bottom },
                    { id: 'br', x: bounds.right, y: bounds.bottom }
                ];
                
                for (let corner of corners) {
                    const distance = Math.sqrt(
                        Math.pow(canvasX - corner.x, 2) + 
                        Math.pow(canvasY - corner.y, 2)
                    );
                    
                    if (distance <= handleSize) {
                        return { corner: corner.id, element: elementType };
                    }
                }
                
                return null;
            }
            
            // æª¢æ¸¬é»æ“Šä½ç½®æ˜¯å¦åœ¨æ–‡å­—æˆ–åœ–ç‰‡ç¯„åœå…§
            function detectDragTarget(canvasX, canvasY) {
                // å„ªå…ˆæª¢æ¸¬è§’è½æ§åˆ¶é»
                let cornerHandle = detectCornerHandle(canvasX, canvasY, 'text');
                if (!cornerHandle) {
                    cornerHandle = detectCornerHandle(canvasX, canvasY, 'image');
                }
                
                if (cornerHandle) {
                    return { type: 'corner', ...cornerHandle };
                }
                
                // æª¢æ¸¬å…ƒç´ æœ¬èº«
                const textBounds = getElementBounds('text');
                if (textBounds && 
                    canvasX >= textBounds.left && canvasX <= textBounds.right &&
                    canvasY >= textBounds.top && canvasY <= textBounds.bottom) {
                    return { type: 'element', element: 'text' };
                }
                
                const imageBounds = getElementBounds('image');
                if (imageBounds && 
                    canvasX >= imageBounds.left && canvasX <= imageBounds.right &&
                    canvasY >= imageBounds.top && canvasY <= imageBounds.bottom) {
                    return { type: 'element', element: 'image' };
                }
                
                return null;
            }
            
            // ç¹ªè£½èª¿æ•´å¤§å°ç®­é ­
            function drawResizeArrow(x, y, cornerId) {
                const arrowLength = 5;
                ctx.beginPath();
                
                switch(cornerId) {
                    case 'tl': // å·¦ä¸Šè§’ - å°è§’ç·šç®­é ­
                        ctx.moveTo(x - arrowLength, y - arrowLength);
                        ctx.lineTo(x + arrowLength, y + arrowLength);
                        ctx.moveTo(x - arrowLength + 2, y - arrowLength);
                        ctx.lineTo(x - arrowLength, y - arrowLength);
                        ctx.lineTo(x - arrowLength, y - arrowLength + 2);
                        ctx.moveTo(x + arrowLength - 2, y + arrowLength);
                        ctx.lineTo(x + arrowLength, y + arrowLength);
                        ctx.lineTo(x + arrowLength, y + arrowLength - 2);
                        break;
                    case 'tr': // å³ä¸Šè§’ - å°è§’ç·šç®­é ­
                        ctx.moveTo(x + arrowLength, y - arrowLength);
                        ctx.lineTo(x - arrowLength, y + arrowLength);
                        ctx.moveTo(x + arrowLength - 2, y - arrowLength);
                        ctx.lineTo(x + arrowLength, y - arrowLength);
                        ctx.lineTo(x + arrowLength, y - arrowLength + 2);
                        ctx.moveTo(x - arrowLength + 2, y + arrowLength);
                        ctx.lineTo(x - arrowLength, y + arrowLength);
                        ctx.lineTo(x - arrowLength, y + arrowLength - 2);
                        break;
                    case 'bl': // å·¦ä¸‹è§’ - å°è§’ç·šç®­é ­
                        ctx.moveTo(x - arrowLength, y + arrowLength);
                        ctx.lineTo(x + arrowLength, y - arrowLength);
                        ctx.moveTo(x - arrowLength + 2, y + arrowLength);
                        ctx.lineTo(x - arrowLength, y + arrowLength);
                        ctx.lineTo(x - arrowLength, y + arrowLength - 2);
                        ctx.moveTo(x + arrowLength - 2, y - arrowLength);
                        ctx.lineTo(x + arrowLength, y - arrowLength);
                        ctx.lineTo(x + arrowLength, y - arrowLength + 2);
                        break;
                    case 'br': // å³ä¸‹è§’ - å°è§’ç·šç®­é ­
                        ctx.moveTo(x + arrowLength, y + arrowLength);
                        ctx.lineTo(x - arrowLength, y - arrowLength);
                        ctx.moveTo(x + arrowLength - 2, y + arrowLength);
                        ctx.lineTo(x + arrowLength, y + arrowLength);
                        ctx.lineTo(x + arrowLength, y + arrowLength - 2);
                        ctx.moveTo(x - arrowLength + 2, y - arrowLength);
                        ctx.lineTo(x - arrowLength, y - arrowLength);
                        ctx.lineTo(x - arrowLength, y - arrowLength + 2);
                        break;
                }
                
                ctx.stroke();
            }
            
            // ç¹ªè£½æ—‹è½‰ç®­é ­
            function drawRotationArrow(x, y, cornerId) {
                const radius = 4.5;
                const arrowSize = 2.5;
                
                ctx.save();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1.8;
                ctx.lineCap = 'round';
                
                // ç¹ªè£½é›™å¼§å½¢æ—‹è½‰ç®­é ­ (â†» ç¬¦è™Ÿé¢¨æ ¼)
                // macOS å„ªåŒ–ï¼šæ›´ç²—çš„ç·šæ¢å’Œæ›´å¤§çš„ç®­é ­
                if (navigator.platform.includes('Mac')) {
                    ctx.lineWidth = 2.2;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 1;
                }
                
                // ç¬¬ä¸€å€‹å¼§å½¢ç®­é ­ (ä¸ŠåŠéƒ¨)
                ctx.beginPath();
                ctx.arc(x, y, radius, -Math.PI * 0.7, -Math.PI * 0.1);
                ctx.stroke();
                
                // ä¸Šå¼§å½¢çš„ç®­é ­é ­
                const topArrowX = x + radius * Math.cos(-Math.PI * 0.1);
                const topArrowY = y + radius * Math.sin(-Math.PI * 0.1);
                const topArrowAngle = -Math.PI * 0.1 + Math.PI / 2;
                
                ctx.beginPath();
                ctx.moveTo(topArrowX, topArrowY);
                ctx.lineTo(
                    topArrowX + arrowSize * Math.cos(topArrowAngle + 0.6),
                    topArrowY + arrowSize * Math.sin(topArrowAngle + 0.6)
                );
                ctx.moveTo(topArrowX, topArrowY);
                ctx.lineTo(
                    topArrowX + arrowSize * Math.cos(topArrowAngle - 0.6),
                    topArrowY + arrowSize * Math.sin(topArrowAngle - 0.6)
                );
                ctx.stroke();
                
                // ç¬¬äºŒå€‹å¼§å½¢ç®­é ­ (ä¸‹åŠéƒ¨)
                ctx.beginPath();
                ctx.arc(x, y, radius, Math.PI * 0.1, Math.PI * 0.7);
                ctx.stroke();
                
                // ä¸‹å¼§å½¢çš„ç®­é ­é ­
                const bottomArrowX = x + radius * Math.cos(Math.PI * 0.7);
                const bottomArrowY = y + radius * Math.sin(Math.PI * 0.7);
                const bottomArrowAngle = Math.PI * 0.7 + Math.PI / 2;
                
                ctx.beginPath();
                ctx.moveTo(bottomArrowX, bottomArrowY);
                ctx.lineTo(
                    bottomArrowX + arrowSize * Math.cos(bottomArrowAngle + 0.6),
                    bottomArrowY + arrowSize * Math.sin(bottomArrowAngle + 0.6)
                );
                ctx.moveTo(bottomArrowX, bottomArrowY);
                ctx.lineTo(
                    bottomArrowX + arrowSize * Math.cos(bottomArrowAngle - 0.6),
                    bottomArrowY + arrowSize * Math.sin(bottomArrowAngle - 0.6)
                );
                ctx.stroke();
                
                ctx.restore();
            }
            
            // æ›´æ–°è§’è½è¦–è¦ºæ•ˆæœ
            function updateCornerVisuals() {
                // é‡ç¹ªæ•´å€‹ç•«å¸ƒä»¥åŒ…å«è§’è½æ§åˆ¶é»
                createFrame(currentFormat);
            }
            
            // é–‹å§‹æ‹–æ›³æˆ–å¤šé»è§¸æ§
            function startDragging(e) {
                e.preventDefault();
                
                // æª¢æŸ¥æ˜¯å¦ç‚ºå¤šé»è§¸æ§
                if (e.touches && e.touches.length === 2) {
                    isMultiTouch = true;
                    isDragging = false;
                    
                    // æª¢æ¸¬ç›®æ¨™å…ƒç´ 
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const center = getTouchCenter(touch1, touch2);
                    dragTarget = detectDragTarget(center.x, center.y);
                    
                    if (dragTarget) {
                        touchStartDistance = getDistance(touch1, touch2);
                        touchStartAngle = getAngle(touch1, touch2);
                        
                        if (dragTarget === 'text') {
                            initialScale = parseFloat(elements.fontSize.value);
                            initialRotation = parseFloat(elements.textRotation.value);
                        } else if (dragTarget === 'image') {
                            initialScale = parseFloat(elements.imageSize.value);
                            initialRotation = parseFloat(elements.imageRotation.value);
                        }
                        
                        canvas.style.cursor = 'grabbing';
                    }
                } else {
                    // å–®é»è§¸æ§æˆ–æ»‘é¼ æ“ä½œ
                    isMultiTouch = false;
                    const pos = getCanvasPosition(e, canvas);
                    const target = detectDragTarget(pos.x, pos.y);
                    
                    if (target) {
                        // è™•ç†è§’è½æ§åˆ¶é»æ‹–æ‹½
                        if (target.type === 'corner') {
                            isCornerDragging = true;
                            dragTarget = target.element;
                            activeCorner = target.corner;
                            cornerMode = isAltPressed ? 'rotate' : 'resize';
                            
                            dragStartX = pos.x;
                            dragStartY = pos.y;
                            
                            if (dragTarget === 'text') {
                                initialScale = parseFloat(elements.fontSize.value);
                                initialRotation = parseFloat(elements.textRotation.value);
                            } else if (dragTarget === 'image') {
                                initialScale = parseFloat(elements.imageSize.value);
                                initialRotation = parseFloat(elements.imageRotation.value);
                            }
                            
                            // è¨­å®šé©ç•¶çš„æ¸¸æ¨™
                            if (cornerMode === 'rotate') {
                                canvas.style.cursor = 'grab';
                            } else {
                                const cursorMap = {
                                    'tl': 'nw-resize', 'tr': 'ne-resize',
                                    'bl': 'sw-resize', 'br': 'se-resize'
                                };
                                canvas.style.cursor = cursorMap[activeCorner];
                            }
                            return;
                        }
                        
                        dragTarget = target.element;
                        
                        // æª¢æŸ¥æ¡Œé¢ä¿®é£¾éµ (åªå°æ»‘é¼ äº‹ä»¶æœ‰æ•ˆ)
                        if (e.type === 'mousedown') {
                            if (e.shiftKey) {
                                // Shift + æ‹–æ›³ = ç¸®æ”¾æ¨¡å¼
                                isScaling = true;
                                lastMouseY = e.clientY;
                                canvas.style.cursor = 'ns-resize';
                                
                                if (dragTarget === 'text') {
                                    initialScale = parseFloat(elements.fontSize.value);
                                } else if (dragTarget === 'image') {
                                    initialScale = parseFloat(elements.imageSize.value);
                                }
                                return;
                            } else if (e.altKey) {
                                // Alt + æ‹–æ›³ = æ—‹è½‰æ¨¡å¼
                                isRotating = true;
                                lastMouseX = e.clientX;
                                canvas.style.cursor = 'ew-resize';
                                
                                if (dragTarget === 'text') {
                                    initialRotation = parseFloat(elements.textRotation.value);
                                } else if (dragTarget === 'image') {
                                    initialRotation = parseFloat(elements.imageRotation.value);
                                }
                                return;
                            }
                        }
                        
                        // ä¸€èˆ¬æ‹–æ›³æ¨¡å¼
                        isDragging = true;
                        dragStartX = pos.x;
                        dragStartY = pos.y;
                        
                        if (dragTarget === 'text') {
                            initialTextX = elements.textPositionX.value;
                            initialTextY = elements.textPositionY.value;
                            canvas.style.cursor = 'grabbing';
                        } else if (dragTarget === 'image') {
                            initialImageX = elements.imagePositionX.value;
                            initialImageY = elements.imagePositionY.value;
                            canvas.style.cursor = 'grabbing';
                        }
                    }
                }
            }
            
            // æ‹–æ›³ä¸­æˆ–å¤šé»è§¸æ§
            function doDragging(e) {
                if ((!isDragging && !isMultiTouch && !isScaling && !isRotating && !isCornerDragging) || !dragTarget) return;
                
                e.preventDefault();
                const config = formats[currentFormat];
                
                // è™•ç†è§’è½æ§åˆ¶é»æ‹–æ‹½
                if (isCornerDragging && e.type === 'mousemove') {
                    const pos = getCanvasPosition(e, canvas);
                    const deltaX = pos.x - dragStartX;
                    const deltaY = pos.y - dragStartY;
                    
                    if (cornerMode === 'resize') {
                        // è§’è½èª¿æ•´å¤§å°é‚è¼¯
                        const bounds = getElementBounds(dragTarget);
                        if (!bounds) return;
                        
                        // è¨ˆç®—è·é›¢ä¸­å¿ƒçš„è®ŠåŒ–
                        const centerX = bounds.centerX;
                        const centerY = bounds.centerY;
                        
                        let scaleFactor = 1;
                        switch(activeCorner) {
                            case 'tl': // å·¦ä¸Šè§’
                                scaleFactor = Math.max(0.1, 1 - (deltaX + deltaY) / 200);
                                break;
                            case 'tr': // å³ä¸Šè§’  
                                scaleFactor = Math.max(0.1, 1 + (deltaX - deltaY) / 200);
                                break;
                            case 'bl': // å·¦ä¸‹è§’
                                scaleFactor = Math.max(0.1, 1 + (-deltaX + deltaY) / 200);
                                break;
                            case 'br': // å³ä¸‹è§’
                                scaleFactor = Math.max(0.1, 1 + (deltaX + deltaY) / 200);
                                break;
                        }
                        
                        if (dragTarget === 'text') {
                            const newSize = Math.max(16, Math.min(200, initialScale * scaleFactor));
                            elements.fontSize.value = Math.round(newSize);
                            elements.fontSizeValue.textContent = Math.round(newSize) + 'px';
                        } else if (dragTarget === 'image') {
                            const newSize = Math.max(10, Math.min(200, initialScale * scaleFactor));
                            elements.imageSize.value = Math.round(newSize);
                            elements.imageSizeValue.textContent = Math.round(newSize) + '%';
                            
                            // åŒæ­¥æ›´æ–°å¤šåœ–ç‰‡ç³»çµ±ä¸­é¸ä¸­åœ–ç‰‡çš„å±¬æ€§
                            if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                                uploadedImages[selectedImageIndex].size = Math.round(newSize);
                            }
                        }
                        
                    } else if (cornerMode === 'rotate') {
                        // è§’è½æ—‹è½‰é‚è¼¯
                        const bounds = getElementBounds(dragTarget);
                        if (!bounds) return;
                        
                        const centerX = bounds.centerX;
                        const centerY = bounds.centerY;
                        
                        // è¨ˆç®—å¾ä¸­å¿ƒåˆ°èµ·å§‹é»çš„è§’åº¦
                        const startAngle = Math.atan2(dragStartY - centerY, dragStartX - centerX);
                        // è¨ˆç®—å¾ä¸­å¿ƒåˆ°ç•¶å‰é»çš„è§’åº¦
                        const currentAngle = Math.atan2(pos.y - centerY, pos.x - centerX);
                        // è§’åº¦å·®ç•°ï¼ˆè½‰æ›ç‚ºåº¦æ•¸ï¼‰
                        const angleDelta = (currentAngle - startAngle) * 180 / Math.PI;
                        
                        if (dragTarget === 'text') {
                            const newRotation = Math.max(-45, Math.min(45, initialRotation + angleDelta));
                            elements.textRotation.value = Math.round(newRotation);
                            elements.textRotationValue.textContent = Math.round(newRotation) + 'Â°';
                        } else if (dragTarget === 'image') {
                            const newRotation = Math.max(-180, Math.min(180, initialRotation + angleDelta));
                            elements.imageRotation.value = Math.round(newRotation);
                            elements.imageRotationValue.textContent = Math.round(newRotation) + 'Â°';
                            
                            // åŒæ­¥æ›´æ–°å¤šåœ–ç‰‡ç³»çµ±ä¸­é¸ä¸­åœ–ç‰‡çš„å±¬æ€§
                            if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                                uploadedImages[selectedImageIndex].rotation = Math.round(newRotation);
                            }
                        }
                    }
                    
                    createFrame(currentFormat);
                    return;
                }
                
                // æ¡Œé¢ç¸®æ”¾æ¨¡å¼ (Shift + æ‹–æ›³)
                if (isScaling && e.type === 'mousemove') {
                    const deltaY = e.clientY - lastMouseY;
                    const scaleFactor = 1 - (deltaY * 0.01); // æ¯åƒç´  1% è®ŠåŒ–
                    
                    if (dragTarget === 'text') {
                        const newSize = Math.max(16, Math.min(200, 
                            initialScale * scaleFactor
                        ));
                        elements.fontSize.value = Math.round(newSize);
                        elements.fontSizeValue.textContent = Math.round(newSize) + 'px';
                    } else if (dragTarget === 'image') {
                        const newSize = Math.max(10, Math.min(200, 
                            initialScale * scaleFactor
                        ));
                        elements.imageSize.value = Math.round(newSize);
                        elements.imageSizeValue.textContent = Math.round(newSize) + '%';
                        
                        // åŒæ­¥æ›´æ–°å¤šåœ–ç‰‡ç³»çµ±ä¸­é¸ä¸­åœ–ç‰‡çš„å±¬æ€§
                        if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                            uploadedImages[selectedImageIndex].size = Math.round(newSize);
                        }
                    }
                    
                    createFrame(currentFormat);
                    return;
                }
                
                // æ¡Œé¢æ—‹è½‰æ¨¡å¼ (Alt + æ‹–æ›³)
                if (isRotating && e.type === 'mousemove') {
                    const deltaX = e.clientX - lastMouseX;
                    const rotationChange = deltaX * 0.5; // æ¯åƒç´  0.5 åº¦è®ŠåŒ–
                    
                    if (dragTarget === 'text') {
                        const newRotation = Math.max(-45, Math.min(45, 
                            initialRotation + rotationChange
                        ));
                        elements.textRotation.value = Math.round(newRotation);
                        elements.textRotationValue.textContent = Math.round(newRotation) + 'Â°';
                    } else if (dragTarget === 'image') {
                        const newRotation = Math.max(-180, Math.min(180, 
                            initialRotation + rotationChange
                        ));
                        elements.imageRotation.value = Math.round(newRotation);
                        elements.imageRotationValue.textContent = Math.round(newRotation) + 'Â°';
                        
                        // åŒæ­¥æ›´æ–°å¤šåœ–ç‰‡ç³»çµ±ä¸­é¸ä¸­åœ–ç‰‡çš„å±¬æ€§
                        if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                            uploadedImages[selectedImageIndex].rotation = Math.round(newRotation);
                        }
                    }
                    
                    createFrame(currentFormat);
                    return;
                }
                
                if (isMultiTouch && e.touches && e.touches.length === 2) {
                    // å¤šé»è§¸æ§ï¼šç¸®æ”¾å’Œæ—‹è½‰
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = getDistance(touch1, touch2);
                    const currentAngle = getAngle(touch1, touch2);
                    
                    // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
                    const scaleChange = currentDistance / touchStartDistance;
                    
                    // è¨ˆç®—æ—‹è½‰è®ŠåŒ–
                    const angleChange = (currentAngle - touchStartAngle) * 180 / Math.PI;
                    
                    if (dragTarget === 'text') {
                        // æ–‡å­—ç¸®æ”¾ï¼ˆèª¿æ•´å­—é«”å¤§å°ï¼‰
                        const newSize = Math.max(16, Math.min(200, 
                            initialScale * scaleChange
                        ));
                        elements.fontSize.value = Math.round(newSize);
                        elements.fontSizeValue.textContent = Math.round(newSize) + 'px';
                        
                        // æ–‡å­—æ—‹è½‰
                        const newRotation = Math.max(-45, Math.min(45, 
                            initialRotation + angleChange
                        ));
                        elements.textRotation.value = Math.round(newRotation);
                        elements.textRotationValue.textContent = Math.round(newRotation) + 'Â°';
                        
                    } else if (dragTarget === 'image') {
                        // åœ–ç‰‡ç¸®æ”¾
                        const newSize = Math.max(10, Math.min(200, 
                            initialScale * scaleChange
                        ));
                        elements.imageSize.value = Math.round(newSize);
                        elements.imageSizeValue.textContent = Math.round(newSize) + '%';
                        
                        // åœ–ç‰‡æ—‹è½‰
                        const newRotation = Math.max(-180, Math.min(180, 
                            initialRotation + angleChange
                        ));
                        elements.imageRotation.value = Math.round(newRotation);
                        elements.imageRotationValue.textContent = Math.round(newRotation) + 'Â°';
                        
                        // åŒæ­¥æ›´æ–°å¤šåœ–ç‰‡ç³»çµ±ä¸­é¸ä¸­åœ–ç‰‡çš„å±¬æ€§
                        if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                            uploadedImages[selectedImageIndex].size = Math.round(newSize);
                            uploadedImages[selectedImageIndex].rotation = Math.round(newRotation);
                        }
                    }
                    
                } else if (isDragging) {
                    // å–®é»è§¸æ§ï¼šä½ç½®æ‹–æ›³
                    const pos = getCanvasPosition(e, canvas);
                    
                    if (dragTarget === 'text') {
                        // è¨ˆç®—æ–°çš„æ–‡å­—ä½ç½®ï¼ˆæ”¯æ´æ°´å¹³å’Œå‚ç›´ç§»å‹•ï¼‰
                        const deltaX = pos.x - dragStartX;
                        const deltaY = pos.y - dragStartY;
                        
                        const newX = Math.max(10, Math.min(90,
                            parseFloat(initialTextX) + (deltaX / config.width) * 100
                        ));
                        const newY = Math.max(10, Math.min(90, 
                            parseFloat(initialTextY) + (deltaY / config.height) * 100
                        ));
                        
                        elements.textPositionX.value = newX;
                        elements.textPositionXValue.textContent = Math.round(newX) + '%';
                        elements.textPositionY.value = newY;
                        elements.textPositionYValue.textContent = Math.round(newY) + '%';
                        
                    } else if (dragTarget === 'image') {
                        // è¨ˆç®—æ–°çš„åœ–ç‰‡ä½ç½®
                        const deltaX = pos.x - dragStartX;
                        const deltaY = pos.y - dragStartY;
                        
                        const newX = Math.max(0, Math.min(100,
                            parseFloat(initialImageX) + (deltaX / config.width) * 100
                        ));
                        const newY = Math.max(0, Math.min(100,
                            parseFloat(initialImageY) + (deltaY / config.height) * 100
                        ));
                        
                        // æ›´æ–° UI æ§åˆ¶é …
                        elements.imagePositionX.value = newX;
                        elements.imagePositionXValue.textContent = Math.round(newX) + '%';
                        elements.imagePositionY.value = newY;
                        elements.imagePositionYValue.textContent = Math.round(newY) + '%';
                        
                        // åŒæ­¥æ›´æ–°å¤šåœ–ç‰‡ç³»çµ±ä¸­é¸ä¸­åœ–ç‰‡çš„å±¬æ€§
                        if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                            uploadedImages[selectedImageIndex].positionX = newX;
                            uploadedImages[selectedImageIndex].positionY = newY;
                        }
                    }
                }
                
                createFrame(currentFormat); // å³æ™‚æ›´æ–°é è¦½
            }
            
            // çµæŸæ‹–æ›³
            function stopDragging(e) {
                if (isDragging || isMultiTouch || isScaling || isRotating || isCornerDragging) {
                    isDragging = false;
                    isMultiTouch = false;
                    isScaling = false;
                    isRotating = false;
                    isCornerDragging = false;
                    dragTarget = null;
                    activeCorner = null;
                    canvas.style.cursor = 'default';
                }
            }
            
            // æ»‘é¼ äº‹ä»¶
            canvas.addEventListener('mousedown', startDragging);
            document.addEventListener('mousemove', doDragging);
            document.addEventListener('mouseup', stopDragging);
            
            // è§¸æ§äº‹ä»¶
            canvas.addEventListener('touchstart', startDragging, { passive: false });
            document.addEventListener('touchmove', doDragging, { passive: false });
            document.addEventListener('touchend', stopDragging);
            
            // æ»‘é¼ æ‡¸åœæ•ˆæœ
            canvas.addEventListener('mousemove', function(e) {
                if (!isDragging && !isMultiTouch && !isScaling && !isRotating && !isCornerDragging) {
                    const pos = getCanvasPosition(e, canvas);
                    const target = detectDragTarget(pos.x, pos.y);
                    
                    if (target) {
                        if (target.type === 'corner') {
                            // è§’è½æ§åˆ¶é»æ‡¸åœæ¸¸æ¨™
                            if (isAltPressed) {
                                // macOS å„ªåŒ–ï¼šä½¿ç”¨æ›´æ˜é¡¯çš„æ—‹è½‰æ¸¸æ¨™
                                canvas.style.cursor = navigator.platform.includes('Mac') ? 'alias' : 'crosshair';
                            } else {
                                // èª¿æ•´å¤§å°æ¨¡å¼
                                const cursorMap = {
                                    'tl': 'nw-resize', 'tr': 'ne-resize',
                                    'bl': 'sw-resize', 'br': 'se-resize'
                                };
                                canvas.style.cursor = cursorMap[target.corner];
                            }
                        } else {
                            // å…ƒç´ æœ¬èº«
                            if (isAltPressed) {
                                canvas.style.cursor = navigator.platform.includes('Mac') ? 'alias' : 'crosshair';
                            } else {
                                canvas.style.cursor = 'grab';
                            }
                        }
                    } else {
                        canvas.style.cursor = 'default';
                    }
                }
            });
        }
        
        // è¨­å®šæ»‘æ¡¿
        function setupSlider(sliderId, valueId, unit) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            
            slider.addEventListener('input', function() {
                valueDisplay.textContent = this.value + unit;
                createFrame(currentFormat);
            });
        }
        
        // åœ–ç‰‡æ»‘æ¡¿è¨­å®šï¼ˆæ”¯æ´å¤šåœ–ç‰‡ï¼‰
        function setupImageSlider(sliderId, valueId, unit) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            
            slider.addEventListener('input', function() {
                const value = this.value;
                valueDisplay.textContent = value + unit;
                
                // æ›´æ–°é¸ä¸­åœ–ç‰‡çš„å±¬æ€§
                if (selectedImageIndex >= 0 && uploadedImages[selectedImageIndex]) {
                    const imageData = uploadedImages[selectedImageIndex];
                    const property = sliderId.replace('image', '').toLowerCase();
                    
                    switch(property) {
                        case 'size':
                            imageData.size = parseInt(value);
                            break;
                        case 'opacity':
                            imageData.opacity = parseInt(value);
                            break;
                        case 'rotation':
                            imageData.rotation = parseInt(value);
                            break;
                        case 'positionx':
                            imageData.positionX = parseInt(value);
                            break;
                        case 'positiony':
                            imageData.positionY = parseInt(value);
                            break;
                    }
                }
                
                createFrame(currentFormat);
            });
        }
        
        // è™•ç†åœ–ç‰‡ä¸Šå‚³ï¼ˆæ”¯æ´å¤šé¸ï¼‰
        function handleImageUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                // å¦‚æœåªæœ‰ä¸€å¼µåœ–ç‰‡ï¼Œä¿æŒå‘ä¸‹ç›¸å®¹
                if (files.length === 1) {
                    handleImageFile(files[0]);
                } else {
                    // å¤šå¼µåœ–ç‰‡è™•ç†
                    handleMultipleImageFiles(files);
                }
            }
        }
        
        // è™•ç†å¤šå¼µåœ–ç‰‡æª”æ¡ˆ
        function handleMultipleImageFiles(files) {
            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    addImageToCollection(file);
                } else {
                    console.warn('è·³ééåœ–ç‰‡æª”æ¡ˆ:', file.name);
                }
            });
        }
        
        // æ·»åŠ åœ–ç‰‡åˆ°é›†åˆ
        function addImageToCollection(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const imageData = {
                        id: Date.now() + Math.random(), // å”¯ä¸€ ID
                        name: file.name,
                        src: e.target.result,
                        image: img,
                        // åœ–ç‰‡å±¬æ€§ï¼ˆæ¯å¼µåœ–ç‰‡ç¨ç«‹ï¼‰
                        size: 100,
                        opacity: 100,
                        rotation: 0,
                        positionX: 50,
                        positionY: 20,
                        behindText: false
                    };
                    
                    uploadedImages.push(imageData);
                    updateImageManager();
                    
                    // è‡ªå‹•é¸ä¸­ç¬¬ä¸€å¼µåœ–ç‰‡
                    if (uploadedImages.length === 1) {
                        selectImage(0);
                        // å•Ÿç”¨åœ–ç‰‡åŠŸèƒ½
                        elements.enableImage.checked = true;
                        elements.imageControls.style.display = 'block';
                    }
                    
                    createFrame(currentFormat);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        // æ›´æ–°åœ–ç‰‡ç®¡ç†é¢æ¿
        function updateImageManager() {
            elements.imageCount.textContent = uploadedImages.length;
            
            if (uploadedImages.length > 0) {
                elements.imageManager.style.display = 'block';
                elements.imagePreview.style.display = 'none'; // éš±è—å–®å¼µé è¦½
                renderImageList();
            } else {
                elements.imageManager.style.display = 'none';
                elements.selectedImageControls.style.display = 'none';
            }
        }
        
        // æ¸²æŸ“åœ–ç‰‡æ¸…å–®
        function renderImageList() {
            elements.imageList.innerHTML = '';
            
            uploadedImages.forEach((imageData, index) => {
                const item = document.createElement('div');
                item.className = `image-item ${index === selectedImageIndex ? 'selected' : ''}`;
                item.innerHTML = `
                    <img src="${imageData.src}" alt="${imageData.name}">
                    <div class="image-item-controls">
                        <button class="image-item-btn delete" onclick="removeImage(${index})" title="åˆªé™¤">Ã—</button>
                        <button class="image-item-btn up" onclick="moveImage(${index}, -1)" title="ä¸Šç§»" ${index === 0 ? 'disabled' : ''}>â†‘</button>
                        <button class="image-item-btn down" onclick="moveImage(${index}, 1)" title="ä¸‹ç§»" ${index === uploadedImages.length - 1 ? 'disabled' : ''}>â†“</button>
                    </div>
                    <div class="image-item-info">
                        <div class="image-item-name" title="${imageData.name}">${imageData.name}</div>
                    </div>
                `;
                
                // é»æ“Šé¸ä¸­åœ–ç‰‡
                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('image-item-btn')) {
                        selectImage(index);
                    }
                });
                
                elements.imageList.appendChild(item);
            });
        }
        
        // é¸ä¸­åœ–ç‰‡
        function selectImage(index) {
            if (index >= 0 && index < uploadedImages.length) {
                selectedImageIndex = index;
                const imageData = uploadedImages[index];
                
                // æ›´æ–°æ§åˆ¶é …é¡¯ç¤º
                elements.selectedImageControls.style.display = 'block';
                elements.selectedImageName.textContent = imageData.name;
                
                // æ›´æ–°æ»‘æ¡¿å€¼åˆ°é¸ä¸­åœ–ç‰‡çš„è¨­å®š
                elements.imageSize.value = imageData.size;
                elements.imageSizeValue.textContent = imageData.size + '%';
                elements.imageOpacity.value = imageData.opacity;
                elements.imageOpacityValue.textContent = imageData.opacity + '%';
                elements.imageRotation.value = imageData.rotation;
                elements.imageRotationValue.textContent = imageData.rotation + 'Â°';
                elements.imagePositionX.value = imageData.positionX;
                elements.imagePositionXValue.textContent = imageData.positionX + '%';
                elements.imagePositionY.value = imageData.positionY;
                elements.imagePositionYValue.textContent = imageData.positionY + '%';
                elements.imageBehindText.checked = imageData.behindText;
                
                // æ›´æ–°å‘ä¸‹ç›¸å®¹çš„ uploadedImage
                uploadedImage = imageData.image;
                
                // é‡æ–°æ¸²æŸ“
                renderImageList();
                createFrame(currentFormat);
            }
        }
        
        // åˆªé™¤åœ–ç‰‡
        function removeImage(index) {
            if (index >= 0 && index < uploadedImages.length) {
                uploadedImages.splice(index, 1);
                
                // èª¿æ•´é¸ä¸­ç´¢å¼•
                if (selectedImageIndex === index) {
                    selectedImageIndex = uploadedImages.length > 0 ? Math.min(index, uploadedImages.length - 1) : -1;
                } else if (selectedImageIndex > index) {
                    selectedImageIndex--;
                }
                
                // æ›´æ–°é¡¯ç¤º
                updateImageManager();
                
                if (selectedImageIndex >= 0) {
                    selectImage(selectedImageIndex);
                } else {
                    uploadedImage = null;
                    elements.selectedImageControls.style.display = 'none';
                }
                
                createFrame(currentFormat);
            }
        }
        
        // ç§»å‹•åœ–ç‰‡é †åº
        function moveImage(index, direction) {
            const newIndex = index + direction;
            if (newIndex >= 0 && newIndex < uploadedImages.length) {
                // äº¤æ›ä½ç½®
                [uploadedImages[index], uploadedImages[newIndex]] = [uploadedImages[newIndex], uploadedImages[index]];
                
                // èª¿æ•´é¸ä¸­ç´¢å¼•
                if (selectedImageIndex === index) {
                    selectedImageIndex = newIndex;
                } else if (selectedImageIndex === newIndex) {
                    selectedImageIndex = index;
                }
                
                // é‡æ–°æ¸²æŸ“
                renderImageList();
                createFrame(currentFormat);
            }
        }
        
        function handleImageFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('è«‹é¸æ“‡åœ–ç‰‡æª”æ¡ˆ (PNG, JPG)');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    uploadedImage = img;
                    elements.imagePreview.src = e.target.result;
                    elements.imagePreview.style.display = 'block';
                    
                    // è‡ªå‹•å•Ÿç”¨åœ–ç‰‡åŠŸèƒ½
                    elements.enableImage.checked = true;
                    elements.imageControls.style.display = 'block';
                    
                    createFrame(currentFormat);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        // ä¸»è¦çš„ç›¸æ¡†å‰µå»ºå‡½æ•¸
        function createFrame(format) {
            const config = formats[format];
            
            // è¨­å®š canvas å°ºå¯¸
            canvas.width = config.width;
            canvas.height = config.height;
            canvas.style.maxWidth = '100%';
            canvas.style.height = 'auto';
            
            // æ›´æ–°è³‡è¨Šé¡¯ç¤º
            canvasInfo.textContent = `${config.width} Ã— ${config.height} åƒç´ `;
            
            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, config.width, config.height);
            
            // ç¹ªè£½é‚Šæ¡†
            drawFrame(ctx, config, currentStyle);
            
            // ç¹ªè£½åœ–ç‰‡ (å¦‚æœå•Ÿç”¨ä¸”åœ¨æ–‡å­—å¾Œæ–¹)
            if (elements.enableImage.checked) {
                drawAllImages(ctx, config, true); // ç¹ªè£½åœ¨æ–‡å­—å¾Œæ–¹çš„åœ–ç‰‡
            }
            
            // ç¹ªè£½æ–‡å­—
            if (elements.enableText.checked && elements.customText.value.trim()) {
                drawCustomText(ctx, config);
            }
            
            // ç¹ªè£½åœ–ç‰‡ (å¦‚æœå•Ÿç”¨ä¸”åœ¨æ–‡å­—å‰æ–¹)
            if (elements.enableImage.checked) {
                drawAllImages(ctx, config, false); // ç¹ªè£½åœ¨æ–‡å­—å‰æ–¹çš„åœ–ç‰‡
            }
            
            // ç¹ªè£½é è¦½è¼”åŠ©ç·šå’Œæ§åˆ¶é» (åƒ…åœ¨æ¡Œé¢ç‰ˆä¸”æœ‰å…ƒç´ æ™‚ï¼Œä¸åŒ…å«åœ¨åŒ¯å‡ºä¸­)
            if (window.innerWidth >= 768) { // æ¡Œé¢ç‰ˆ
                if (elements.enableText.checked && elements.customText.value.trim()) {
                    drawTextBoundingBox(config);  // æ–‡å­—è™›ç·šé‚Šç•Œæ¡†
                    drawCornerHandles('text');
                }
                if (elements.enableImage.checked && uploadedImage) {
                    drawCornerHandles('image');
                }
            }
        }
        
        // ç¹ªè£½è‡ªå®šç¾©æ–‡å­—
        function drawCustomText(ctx, config) {
            const text = elements.customText.value.trim();
            if (!text) return;
            
            ctx.save();
            
            // è¨ˆç®—æ–‡å­—ä½ç½®
            const textX = config.width * (elements.textPositionX.value / 100);
            const textY = config.height * (elements.textPositionY.value / 100);
            
            // è¨­å®šå­—é«”
            let fontFamily = elements.fontFamily.value;
            if (fontFamily === 'cursive') {
                fontFamily = '"Brush Script MT", "Lucida Handwriting", "Apple Chancery", cursive';
            }
            
            const fontSize = parseInt(elements.fontSize.value);
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // æ–‡å­—æ—‹è½‰
            if (elements.textRotation.value != 0) {
                ctx.translate(textX, textY);
                ctx.rotate((elements.textRotation.value * Math.PI) / 180);
                ctx.translate(-textX, -textY);
            }
            
            // è¨­å®šé™°å½±
            const shadowBlur = parseInt(elements.shadowBlur.value);
            if (shadowBlur > 0) {
                ctx.shadowColor = elements.shadowColor.value;
                ctx.shadowBlur = shadowBlur;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
            }
            
            // ç¹ªè£½æ–‡å­—
            ctx.fillStyle = elements.textColor.value;
            
            // è™•ç†å¤šè¡Œæ–‡å­—
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2;
            const startY = textY - ((lines.length - 1) * lineHeight) / 2;
            
            lines.forEach((line, index) => {
                ctx.fillText(line, textX, startY + (index * lineHeight));
            });
            
            ctx.restore();
        }
        
        // ç¹ªè£½æ‰€æœ‰åœ–ç‰‡ï¼ˆå¤šåœ–ç‰‡æ”¯æ´ï¼‰
        function drawAllImages(ctx, config, behindText = false) {
            if (uploadedImages.length > 0) {
                // ä½¿ç”¨å¤šåœ–ç‰‡ç³»çµ±
                uploadedImages.forEach(imageData => {
                    if (imageData.behindText === behindText) {
                        drawSingleImage(ctx, config, imageData);
                    }
                });
            } else if (uploadedImage) {
                // å‘ä¸‹ç›¸å®¹ï¼šä½¿ç”¨èˆŠçš„å–®åœ–ç‰‡ç³»çµ±
                const isBehindText = elements.imageBehindText.checked;
                if (isBehindText === behindText) {
                    drawCustomImage(ctx, config);
                }
            }
        }
        
        // ç¹ªè£½å–®å¼µåœ–ç‰‡ï¼ˆæ–°çš„å¤šåœ–ç‰‡ç³»çµ±ï¼‰
        function drawSingleImage(ctx, config, imageData) {
            if (!imageData || !imageData.image) return;
            
            ctx.save();
            
            // ä½¿ç”¨åœ–ç‰‡è‡ªå·±çš„å±¬æ€§
            const size = imageData.size / 100;
            const opacity = imageData.opacity / 100;
            const rotation = imageData.rotation;
            const posX = (imageData.positionX / 100) * config.width;
            const posY = (imageData.positionY / 100) * config.height;
            
            // è¨ˆç®—ç¸®æ”¾å°ºå¯¸
            const maxSize = Math.min(config.width, config.height) * 0.8;
            const scale = (maxSize * size) / Math.max(imageData.image.width, imageData.image.height);
            const drawWidth = imageData.image.width * scale;
            const drawHeight = imageData.image.height * scale;
            
            // è¨­å®šé€æ˜åº¦
            ctx.globalAlpha = opacity;
            
            // ç§»å‹•åˆ°åœ–ç‰‡ä¸­å¿ƒä¸¦æ—‹è½‰
            ctx.translate(posX, posY);
            ctx.rotate((rotation * Math.PI) / 180);
            
            // ç¹ªè£½åœ–ç‰‡
            ctx.drawImage(
                imageData.image,
                -drawWidth / 2,
                -drawHeight / 2,
                drawWidth,
                drawHeight
            );
            
            ctx.restore();
        }
        
        // ç¹ªè£½è‡ªå®šç¾©åœ–ç‰‡ï¼ˆå‘ä¸‹ç›¸å®¹ï¼‰
        function drawCustomImage(ctx, config) {
            if (!uploadedImage) return;
            
            ctx.save();
            
            // è¨ˆç®—åœ–ç‰‡ä½ç½®å’Œå°ºå¯¸
            const size = parseInt(elements.imageSize.value) / 100;
            const opacity = parseInt(elements.imageOpacity.value) / 100;
            const rotation = parseInt(elements.imageRotation.value);
            const posX = (parseInt(elements.imagePositionX.value) / 100) * config.width;
            const posY = (parseInt(elements.imagePositionY.value) / 100) * config.height;
            
            // è¨ˆç®—ç¸®æ”¾å°ºå¯¸
            const maxSize = Math.min(config.width, config.height) * 0.8;
            const scale = (maxSize * size) / Math.max(uploadedImage.width, uploadedImage.height);
            const drawWidth = uploadedImage.width * scale;
            const drawHeight = uploadedImage.height * scale;
            
            // è¨­å®šé€æ˜åº¦
            ctx.globalAlpha = opacity;
            
            // ç§»å‹•åˆ°åœ–ç‰‡ä¸­å¿ƒä¸¦æ—‹è½‰
            ctx.translate(posX, posY);
            if (rotation !== 0) {
                ctx.rotate((rotation * Math.PI) / 180);
            }
            
            // ç¹ªè£½åœ–ç‰‡
            ctx.drawImage(
                uploadedImage,
                -drawWidth / 2,
                -drawHeight / 2,
                drawWidth,
                drawHeight
            );
            
            ctx.restore();
        }
        
        // ç¹ªè£½é‚Šæ¡†åŸºç¤å‡½æ•¸ (ä¿ç•™åŸæœ‰çš„é‚Šæ¡†æ¨£å¼)
        function drawFrame(ctx, config, style) {
            switch(style) {
                case 'modern-gallery':
                    drawModernGalleryFrame(ctx, config);
                    break;
                case 'gradient-glow':
                    drawGradientGlowFrame(ctx, config);
                    break;
                case 'geometric-art':
                    drawGeometricArtFrame(ctx, config);
                    break;
                case 'minimal-lines':
                    drawMinimalLinesFrame(ctx, config);
                    break;
                case 'tech-modern':
                    drawTechModernFrame(ctx, config);
                    break;
                default:
                    drawModernGalleryFrame(ctx, config);
            }
        }
        
        // è¼”åŠ©å‡½æ•¸ï¼šç¹ªè£½åœ“è§’çŸ©å½¢
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        // é‚Šæ¡†ç¹ªè£½å‡½æ•¸å€‘
        function drawModernGalleryFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            const cornerRadius = 8;
            
            ctx.save();
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, cornerRadius);
            ctx.stroke();
            
            ctx.strokeStyle = '#f9fafb';
            ctx.lineWidth = 3;
            const innerMargin = borderWidth + 5;
            drawRoundedRect(ctx, innerMargin, innerMargin, config.width - innerMargin * 2, config.height - innerMargin * 2, cornerRadius - 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawGradientGlowFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            
            ctx.save();
            const gradient = ctx.createLinearGradient(0, 0, config.width, config.height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(0.5, '#764ba2');
            gradient.addColorStop(1, '#f093fb');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            drawRoundedRect(ctx, margin, margin, config.width - borderWidth, config.height - borderWidth, 12);
            ctx.stroke();
            
            ctx.shadowColor = 'rgba(102, 126, 234, 0.5)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawGeometricArtFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            
            ctx.save();
            ctx.strokeStyle = '#FF6B35';
            ctx.lineWidth = borderWidth;
            
            const margin = borderWidth / 2;
            ctx.strokeRect(margin, margin, config.width - borderWidth, config.height - borderWidth);
            
            // å¹¾ä½•è£é£¾
            ctx.strokeStyle = '#4ECDC4';
            ctx.lineWidth = 3;
            const step = borderWidth * 2;
            
            for (let i = 0; i < 4; i++) {
                const offset = step + (i * step);
                ctx.strokeRect(offset, offset, config.width - (offset * 2), config.height - (offset * 2));
            }
            
            ctx.restore();
        }
        
        function drawMinimalLinesFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            
            ctx.save();
            ctx.strokeStyle = '#2D3748';
            ctx.lineWidth = 2;
            
            const margin = borderWidth;
            const lineLength = 60;
            
            // å››å€‹è§’çš„ç·šæ¢
            // å·¦ä¸Šè§’
            ctx.beginPath();
            ctx.moveTo(margin, margin + lineLength);
            ctx.lineTo(margin, margin);
            ctx.lineTo(margin + lineLength, margin);
            ctx.stroke();
            
            // å³ä¸Šè§’
            ctx.beginPath();
            ctx.moveTo(config.width - margin - lineLength, margin);
            ctx.lineTo(config.width - margin, margin);
            ctx.lineTo(config.width - margin, margin + lineLength);
            ctx.stroke();
            
            // å³ä¸‹è§’
            ctx.beginPath();
            ctx.moveTo(config.width - margin, config.height - margin - lineLength);
            ctx.lineTo(config.width - margin, config.height - margin);
            ctx.lineTo(config.width - margin - lineLength, config.height - margin);
            ctx.stroke();
            
            // å·¦ä¸‹è§’
            ctx.beginPath();
            ctx.moveTo(margin + lineLength, config.height - margin);
            ctx.lineTo(margin, config.height - margin);
            ctx.lineTo(margin, config.height - margin - lineLength);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawTechModernFrame(ctx, config) {
            const borderWidth = config.borderWidth;
            
            ctx.save();
            
            // ä¸»é‚Šæ¡†
            const gradient = ctx.createLinearGradient(0, 0, config.width, 0);
            gradient.addColorStop(0, '#00D4FF');
            gradient.addColorStop(0.5, '#3B82F6');
            gradient.addColorStop(1, '#8B5CF6');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = borderWidth;
            ctx.lineCap = 'round';
            
            const margin = borderWidth / 2;
            ctx.strokeRect(margin, margin, config.width - borderWidth, config.height - borderWidth);
            
            // å…§éƒ¨ç§‘æŠ€ç·šæ¢
            ctx.strokeStyle = '#00D4FF';
            ctx.lineWidth = 2;
            
            const innerMargin = borderWidth + 10;
            const stepSize = 30;
            
            // æ°´å¹³ç·šæ¢
            for (let y = innerMargin; y < config.height - innerMargin; y += stepSize) {
                ctx.beginPath();
                ctx.moveTo(innerMargin, y);
                ctx.lineTo(innerMargin + 20, y);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(config.width - innerMargin - 20, y);
                ctx.lineTo(config.width - innerMargin, y);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // ä¸‹è¼‰åŠŸèƒ½ (ä¸åŒ…å«é è¦½è¼”åŠ©ç·šå’Œæ§åˆ¶é»)
        function downloadFrame() {
            const format = formats[currentFormat];
            const filename = `frame_${currentFormat}_${currentStyle}_${format.width}x${format.height}.png`;
            
            // é‡æ–°ç¹ªè£½ç´”æ·¨ç‰ˆæœ¬ (ä¸å«é è¦½è¼”åŠ©å…ƒç´ )
            createCleanFrame(currentFormat);
            
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // æ¢å¾©é è¦½ç‰ˆæœ¬ (å«è¼”åŠ©å…ƒç´ )
                createFrame(currentFormat);
            }, 'image/png');
        }
        
        // å‰µå»ºç´”æ·¨ç‰ˆæœ¬çš„ç›¸æ¡† (ä¸å«é è¦½è¼”åŠ©å…ƒç´ )
        function createCleanFrame(format) {
            const config = formats[format];
            
            // è¨­å®š canvas å°ºå¯¸
            canvas.width = config.width;
            canvas.height = config.height;
            canvas.style.maxWidth = '100%';
            canvas.style.height = 'auto';
            
            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, config.width, config.height);
            
            // ç¹ªè£½é‚Šæ¡†
            drawFrame(ctx, config, currentStyle);
            
            // ç¹ªè£½åœ–ç‰‡ (å¦‚æœå•Ÿç”¨ä¸”åœ¨æ–‡å­—å¾Œæ–¹)
            if (elements.enableImage.checked) {
                drawAllImages(ctx, config, true); // ç¹ªè£½åœ¨æ–‡å­—å¾Œæ–¹çš„åœ–ç‰‡
            }
            
            // ç¹ªè£½æ–‡å­—
            if (elements.enableText.checked && elements.customText.value.trim()) {
                drawCustomText(ctx, config);
            }
            
            // ç¹ªè£½åœ–ç‰‡ (å¦‚æœå•Ÿç”¨ä¸”åœ¨æ–‡å­—å‰æ–¹)
            if (elements.enableImage.checked) {
                drawAllImages(ctx, config, false); // ç¹ªè£½åœ¨æ–‡å­—å‰æ–¹çš„åœ–ç‰‡
            }
            
            // æ³¨æ„ï¼šé€™è£¡ä¸ç¹ªè£½è™›ç·šé‚Šç•Œæ¡†å’Œè§’è½æ§åˆ¶é»
        }
        
        function downloadAllFrames() {
            const originalFormat = currentFormat;
            const formatKeys = Object.keys(formats);
            let downloadCount = 0;
            
            function downloadNext() {
                if (downloadCount < formatKeys.length) {
                    const format = formatKeys[downloadCount];
                    currentFormat = format;
                    createFrame(format);
                    
                    setTimeout(() => {
                        const config = formats[format];
                        const filename = `frame_${format}_${currentStyle}_${config.width}x${config.height}.png`;
                        
                        // ç”Ÿæˆç´”æ·¨ç‰ˆæœ¬ (ä¸å«é è¦½è¼”åŠ©å…ƒç´ )
                        createCleanFrame(format);
                        
                        canvas.toBlob(function(blob) {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            downloadCount++;
                            downloadNext();
                        }, 'image/png');
                    }, 100);
                } else {
                    // æ¢å¾©åŸå§‹æ ¼å¼
                    currentFormat = originalFormat;
                    createFrame(originalFormat);
                }
            }
            
            downloadNext();
        }
        
        // ç¹ªè£½æ–‡å­—è™›ç·šé‚Šç•Œæ¡† (åƒ…é è¦½ä½¿ç”¨ï¼Œä¸æœƒåŒ¯å‡ºåˆ° PNG)
        function drawTextBoundingBox(config) {
            const text = elements.customText.value.trim();
            if (!text) return;
            
            ctx.save();
            
            // è¨ˆç®—æ–‡å­—ä½ç½®å’Œåƒæ•¸
            const textX = config.width * (elements.textPositionX.value / 100);
            const textY = config.height * (elements.textPositionY.value / 100);
            const fontSize = parseInt(elements.fontSize.value);
            const rotation = (elements.textRotation.value * Math.PI) / 180;
            
            // è¨­å®šå­—é«”ä»¥è¨ˆç®—æ–‡å­—å°ºå¯¸
            let fontFamily = elements.fontFamily.value;
            if (fontFamily === 'cursive') {
                fontFamily = '"Brush Script MT", "Lucida Handwriting", "Apple Chancery", cursive';
            }
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // è¨ˆç®—å¤šè¡Œæ–‡å­—çš„ç¸½å°ºå¯¸
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2;
            let maxWidth = 0;
            
            // æ‰¾å‡ºæœ€å¯¬çš„ä¸€è¡Œ
            lines.forEach(line => {
                const metrics = ctx.measureText(line);
                maxWidth = Math.max(maxWidth, metrics.width);
            });
            
            const totalHeight = lines.length * lineHeight;
            const padding = fontSize * 0.1; // 10% å…§è·
            
            // é‚Šç•Œæ¡†å°ºå¯¸
            const boxWidth = maxWidth + (padding * 2);
            const boxHeight = totalHeight + (padding * 2);
            
            // ç§»å‹•åˆ°æ–‡å­—ä¸­å¿ƒä¸¦æ—‹è½‰
            ctx.translate(textX, textY);
            if (rotation !== 0) {
                ctx.rotate(rotation);
            }
            
            // è¨­å®šè™›ç·šæ¨£å¼
            ctx.setLineDash([5, 5]); // 5px å¯¦ç·šï¼Œ5px ç©ºç™½
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.6)'; // åŠé€æ˜è—è‰²
            ctx.lineWidth = 1;
            
            // ç¹ªè£½è™›ç·šçŸ©å½¢
            ctx.strokeRect(
                -boxWidth / 2,
                -boxHeight / 2,
                boxWidth,
                boxHeight
            );
            
            // é‡ç½®è™›ç·šè¨­å®š
            ctx.setLineDash([]);
            
            ctx.restore();
        }

        function resetAll() {
            // é‡ç½®æ‰€æœ‰æ§åˆ¶é …
            elements.enableText.checked = true;
            elements.customText.value = '';
            elements.fontFamily.value = 'cursive';
            elements.fontSize.value = 72;
            elements.fontSizeValue.textContent = '72px';
            elements.textColor.value = '#FFD700';
            elements.shadowColor.value = '#000000';
            elements.shadowBlur.value = 3;
            elements.shadowBlurValue.textContent = '3px';
            elements.textRotation.value = 0;
            elements.textRotationValue.textContent = '0Â°';
            elements.textPositionY.value = 85;
            elements.textPositionYValue.textContent = '85%';
            
            elements.enableImage.checked = false;
            elements.imageControls.style.display = 'none';
            elements.imagePreview.style.display = 'none';
            elements.imageSize.value = 100;
            elements.imageSizeValue.textContent = '100%';
            elements.imageOpacity.value = 100;
            elements.imageOpacityValue.textContent = '100%';
            elements.imageRotation.value = 0;
            elements.imageRotationValue.textContent = '0Â°';
            elements.imagePositionX.value = 50;
            elements.imagePositionXValue.textContent = '50%';
            elements.imagePositionY.value = 20;
            elements.imagePositionYValue.textContent = '20%';
            elements.imageBehindText.checked = false;
            
            // æ¸…é™¤å¤šåœ–ç‰‡å’Œå–®åœ–ç‰‡
            uploadedImages = [];
            selectedImageIndex = -1;
            uploadedImage = null;
            
            // éš±è—ç›¸é—œ UI
            elements.imageManager.style.display = 'none';
            elements.selectedImageControls.style.display = 'none';
            elements.imagePreview.style.display = 'none';
            
            createFrame(currentFormat);
        }
    </script>
</body>
</html>
